<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>5m10v3&#39;s blog</title>
  
  
  <link href="https://5m10v3.github.io/atom.xml" rel="self"/>
  
  <link href="https://5m10v3.github.io/"/>
  <updated>2024-06-01T13:49:22.605Z</updated>
  <id>https://5m10v3.github.io/</id>
  
  <author>
    <name>5m10v3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日记(23)</title>
    <link href="https://5m10v3.github.io/2024/06/01/%E6%97%A5%E8%AE%B0(24)/"/>
    <id>https://5m10v3.github.io/2024/06/01/%E6%97%A5%E8%AE%B0(24)/</id>
    <published>2024-05-31T16:00:00.000Z</published>
    <updated>2024-06-01T13:49:22.605Z</updated>
    
    <content type="html"><![CDATA[<p>上一次写日记已经是半个多月前了，这半个多月太忙了，还出去了一周的时间。<br>回来这几天勉强把状态调整了回来，今天打了一个比赛，做了一个迷宫题，但不是传统的那种迷宫题，这个比赛的时间也短，最后就差一分钟！一分钟！，就能把这个flag给交上去了😔😔😔</p><p>总的来说自己对这类题的掌握程度还是不足，今天学长又给了一道迷宫的题，比较难调，是一个类似树状的</p><p>近期规划:</p><ul><li>多复现一些大比赛的题目</li><li>同时基本功也不能落下</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一次写日记已经是半个多月前了，这半个多月太忙了，还出去了一周的时间。&lt;br&gt;回来这几天勉强把状态调整了回来，今天打了一个比赛，做了一个迷宫题，但不是传统的那种迷宫题，这个比赛的时间也短，最后就差一分钟！一分钟！，就能把这个flag给交上去了😔😔😔&lt;/p&gt;
&lt;p&gt;总的</summary>
      
    
    
    
    <category term="日记" scheme="https://5m10v3.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>2024CISCN(初赛)解题思路及复现</title>
    <link href="https://5m10v3.github.io/2024/05/31/2024CISCN(%E5%88%9D%E8%B5%9B)%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
    <id>https://5m10v3.github.io/2024/05/31/2024CISCN(%E5%88%9D%E8%B5%9B)%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%A4%8D%E7%8E%B0/</id>
    <published>2024-05-30T16:00:00.000Z</published>
    <updated>2024-05-31T13:32:24.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="asm-re"><a href="#asm-re" class="headerlink" title="asm_re"></a>asm_re</h2><p>直接手撕汇编</p><p><img src="/../image/688.png" class="lazyload" data-srcset="/../image/688.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="688"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正向加密过程</span></span><br><span class="line">enc=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc[i]*=<span class="number">0x50</span></span><br><span class="line">    enc[i]+=<span class="number">0x14</span></span><br><span class="line">    enc[i]^=<span class="number">0x4D</span></span><br><span class="line">    enc[i]+=<span class="number">0x1E</span></span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enc=[<span class="number">0x1FD7</span>,<span class="number">0x21B7</span>,<span class="number">0x1E47</span>,<span class="number">0x2027</span>,<span class="number">0x26E7</span>,<span class="number">0x10D7</span>,<span class="number">0x1127</span>,<span class="number">0x2007</span>,<span class="number">0x11C7</span>,<span class="number">0x1E47</span>,<span class="number">0x1017</span>,<span class="number">0x1017</span>,<span class="number">0x11F7</span>,<span class="number">0x2007</span>,<span class="number">0x1037</span>,<span class="number">0x1107</span>,<span class="number">0x1F17</span>,<span class="number">0x10D7</span>,<span class="number">0x1017</span>,<span class="number">0x1017</span>,<span class="number">0x1F67</span>,<span class="number">0x1017</span>,<span class="number">0x11C7</span>,<span class="number">0x11C7</span>,<span class="number">0x1017</span>,<span class="number">0x1FD7</span>,<span class="number">0x1F17</span>,<span class="number">0x1107</span>,<span class="number">0x0F47</span>,<span class="number">0x1127</span>,<span class="number">0x1037</span>,<span class="number">0x1E47</span>,<span class="number">0x1037</span>,<span class="number">0x1FD7</span>,<span class="number">0x1107</span>,<span class="number">0x1FD7</span>,<span class="number">0x1107</span>,<span class="number">0x2787</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc[i]-=<span class="number">0x1E</span></span><br><span class="line">    enc[i]^=<span class="number">0x4D</span></span><br><span class="line">    enc[i]-=<span class="number">0x14</span></span><br><span class="line">    enc[i]//=<span class="number">0x50</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc[i]),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="androidso-re"><a href="#androidso-re" class="headerlink" title="androidso_re"></a>androidso_re</h2><p><img src="/../image/689.png" class="lazyload" data-srcset="/../image/689.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="689"></p><p>flag的加密在inspect这个类里面</p><p>经过了DES(CBC模式)加密+base64加密</p><p>那么我们需要得到DES加密的IV和key</p><p>在libSecret_entrance.so里面</p><p><img src="/../image/690.png" class="lazyload" data-srcset="/../image/690.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="690"></p><p>分别在getiv和getkey里面把a1的类型变一下改成<strong>JNIEnv</strong></p><p><img src="/../image/691.png" class="lazyload" data-srcset="/../image/691.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="691"></p><p><img src="/../image/692.png" class="lazyload" data-srcset="/../image/692.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="692"></p><p>然后我们直接利用jnitrace</p><p><img src="/../image/693.png" class="lazyload" data-srcset="/../image/693.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="693"></p><p><img src="/../image/694.png" class="lazyload" data-srcset="/../image/694.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="694"></p><p><img src="/../image/695.png" class="lazyload" data-srcset="/../image/695.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="695"></p><h2 id="whereThel1b"><a href="#whereThel1b" class="headerlink" title="whereThel1b"></a>whereThel1b</h2><p>出题人自己编写的动态链接库</p><p><img src="/../image/696.png" class="lazyload" data-srcset="/../image/696.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="696"></p><p>真正对明文进行处理的函数时whereThelib这个库里面的trytry函数</p><p>我们可以先搜索init，发现有一个PyInit_whereThel1b这个函数</p><p><img src="/../image/697.png" class="lazyload" data-srcset="/../image/697.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="697"></p><p>然后我们就可以找到初始化这些模块的地方__pyx_moduledef</p><p><img src="/../image/698.png" class="lazyload" data-srcset="/../image/698.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="698"></p><p>这里定义了一个随机数种子</p><p>然后后面又调用了whereistheflag1</p><p><img src="/../image/699.png" class="lazyload" data-srcset="/../image/699.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="699"></p><p>说明对字符的处理在whereistheflag1里面</p><p>在whereistheflag1里面先调用了一个base64，说明先进行了base64加密</p><p><img src="/../image/700.png" class="lazyload" data-srcset="/../image/700.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="700"></p><p>还是生成一个随机数，生成的范围时是**(0,len(arr))**</p><p><img src="/../image/701.png" class="lazyload" data-srcset="/../image/701.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="701"></p><p><img src="/../image/703.png" class="lazyload" data-srcset="/../image/703.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="703"></p><p>这里还调用了一下xor</p><p><img src="/../image/702.png" class="lazyload" data-srcset="/../image/702.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="702"></p><p>这里整理一下加密的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">whereistheflag1</span>(<span class="params">pla</span>):</span><br><span class="line">    <span class="comment"># 创建一个空列表</span></span><br><span class="line">    result_list = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 导入模块 &#x27;base64&#x27; 或获取其全局变量</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> base64</span><br><span class="line">        b64encode_func = base64.b64encode</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Cannot find the module &#x27;base64&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 导入模块 &#x27;random&#x27; 或获取其全局变量</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        randint_func = random.randint</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Cannot find the module &#x27;random&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对输入的参数进行编码处理</span></span><br><span class="line">    encoded_pla = b64encode_func(pla)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取编码后字符串的长度</span></span><br><span class="line">    length = <span class="built_in">len</span>(encoded_pla)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机生成一些数字并与编码后的字符串进行异或操作</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        random_int = randint_func(<span class="number">0</span>, <span class="built_in">len</span>(arr))</span><br><span class="line">        result_list.append(random_int ^ encoded_pla[_])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_list</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">enc</span>):</span><br><span class="line">     random.seed()<span class="comment">#随机数种子的参数不知道</span></span><br><span class="line">     whereiftheflag1(enc)   </span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">&quot;__main__&quot;</span> </span><br><span class="line">    enc=<span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line">    enc=byte(enc)</span><br><span class="line">    encode()</span><br></pre></td></tr></table></figure><p>由于随机数种子的参数我们不知道</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">125</span>):</span><br><span class="line"> random.seed(j)</span><br><span class="line"> encry = [<span class="number">108</span>, <span class="number">117</span>, <span class="number">72</span>, <span class="number">80</span>, <span class="number">64</span>, <span class="number">49</span>, <span class="number">99</span>, <span class="number">19</span>, <span class="number">69</span>, <span class="number">115</span>, <span class="number">94</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">115</span>, <span class="number">71</span>, <span class="number">95</span>, <span class="number">84</span>, <span class="number">89</span>, <span class="number">56</span>, <span class="number">101</span>, <span class="number">70</span>, <span class="number">2</span>, <span class="number">84</span>, <span class="number">75</span>, <span class="number">127</span>, <span class="number">68</span>, <span class="number">103</span>, <span class="number">85</span>, <span class="number">105</span>, <span class="number">113</span>, <span class="number">80</span>, <span class="number">103</span>, <span class="number">95</span>, <span class="number">67</span>, <span class="number">81</span>, <span class="number">7</span>, <span class="number">113</span>, <span class="number">70</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">92</span>, <span class="number">124</span>, <span class="number">93</span>, <span class="number">120</span>, <span class="number">104</span>, <span class="number">108</span>, <span class="number">106</span>, <span class="number">17</span>, <span class="number">80</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">75</span>, <span class="number">93</span>, <span class="number">68</span>, <span class="number">121</span>, <span class="number">26</span>]</span><br><span class="line"> keys = [random.randint(<span class="number">0</span>, <span class="built_in">len</span>(encry)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(encry))]</span><br><span class="line"> flag = []</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(encry)):</span><br><span class="line">    flag.append(keys[i] ^ encry[i])</span><br><span class="line"> <span class="keyword">try</span>:</span><br><span class="line">     <span class="built_in">print</span>(base64.b64decode((<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, flag))).encode()))</span><br><span class="line"> <span class="keyword">except</span> binascii.Error:</span><br><span class="line">     <span class="keyword">continue</span></span><br><span class="line"><span class="comment">#b&#x27;flag&#123;7f9a2d3c-07de-11ef-be5e-cf1e88674c0b&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="gdb-debug"><a href="#gdb-debug" class="headerlink" title="gdb_debug"></a>gdb_debug</h2><p>加密逻辑非常清楚</p><p>有三处异或</p><p>在生成的随机数那里，有一个办法</p><p>在它调用rand这个函数之后，后面下一个条件断点</p><p><img src="/../image/704.png" class="lazyload" data-srcset="/../image/704.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="704"></p><p>我们需要下三处条件断点，然后得出三处生成的随机数数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flag[<span class="number">38</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> enc[<span class="number">38</span>] = &#123; <span class="number">0x63</span>,<span class="number">0x6f</span>,<span class="number">0x6e</span>,<span class="number">0x67</span>,<span class="number">0x72</span>,<span class="number">0x61</span>,<span class="number">0x74</span>,<span class="number">0x75</span>,<span class="number">0x6c</span>,<span class="number">0x61</span>,<span class="number">0x74</span>,<span class="number">0x69</span>,<span class="number">0x6f</span>,<span class="number">0x6e</span>,<span class="number">0x73</span>,<span class="number">0x74</span>,<span class="number">0x6f</span>,<span class="number">0x79</span>,<span class="number">0x6f</span>,<span class="number">0x75</span>,<span class="number">0x63</span>,<span class="number">0x6f</span>,<span class="number">0x6e</span>,<span class="number">0x67</span>,<span class="number">0x72</span>,<span class="number">0x61</span>,<span class="number">0x74</span>,<span class="number">0x75</span>,<span class="number">0x6c</span>,<span class="number">0x61</span>,<span class="number">0x74</span>,<span class="number">0x69</span>,<span class="number">0x6f</span>,<span class="number">0x6e</span>,<span class="number">0x73</span>,<span class="number">0x74</span>,<span class="number">0x6f</span>,<span class="number">0x79</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> arr1[<span class="number">38</span>] = &#123; <span class="number">0xBF</span>, <span class="number">0xD7</span>, <span class="number">0x2E</span>, <span class="number">0xDA</span>, <span class="number">0xEE</span>, <span class="number">0xA8</span>, <span class="number">0x1A</span>, <span class="number">0x10</span>, <span class="number">0x83</span>, <span class="number">0x73</span>, <span class="number">0xAC</span>, <span class="number">0xF1</span>, <span class="number">0x06</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0x88</span>, <span class="number">0x04</span>, <span class="number">0xD7</span>, <span class="number">0x12</span>, <span class="number">0xFE</span>, <span class="number">0xB5</span>, <span class="number">0xE2</span>, <span class="number">0x61</span>, <span class="number">0xB7</span>, <span class="number">0x3D</span>, <span class="number">0x07</span>, <span class="number">0x4A</span>, <span class="number">0xE8</span>, <span class="number">0x96</span>, <span class="number">0xA2</span>, <span class="number">0x9D</span>, <span class="number">0x4D</span>, <span class="number">0xBC</span>, <span class="number">0x81</span>, <span class="number">0x8C</span>, <span class="number">0xE9</span>, <span class="number">0x88</span>, <span class="number">0x78</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> xor[] = &#123; <span class="number">0xd9</span>,<span class="number">0x0f</span>,<span class="number">0x18</span>,<span class="number">0xbd</span>,<span class="number">0xc7</span>,<span class="number">0x16</span>,<span class="number">0x81</span>,<span class="number">0xbe</span>,<span class="number">0xf8</span>,<span class="number">0x4a</span>,<span class="number">0x65</span>,<span class="number">0xf2</span>,<span class="number">0x5d</span>,<span class="number">0xab</span>,<span class="number">0x2b</span>,<span class="number">0x33</span>,<span class="number">0xd4</span>,<span class="number">0xa5</span>,<span class="number">0x67</span>,<span class="number">0x98</span>,<span class="number">0x9f</span>,<span class="number">0x7e</span>,<span class="number">0x2b</span>,<span class="number">0x5d</span>,<span class="number">0xc2</span>,<span class="number">0xaf</span>,<span class="number">0x8e</span>,<span class="number">0x3a</span>,<span class="number">0x4c</span>,<span class="number">0xa5</span>,<span class="number">0x75</span>,<span class="number">0x25</span>,<span class="number">0xb4</span>,<span class="number">0x8d</span>,<span class="number">0xe3</span>,<span class="number">0x7b</span>,<span class="number">0xa3</span>,<span class="number">0x64</span> &#125;;</span><br><span class="line"><span class="type">uint32_t</span> xor1[] = &#123; <span class="number">0x5397b3de</span>,<span class="number">0x716150aa</span>,<span class="number">0x1dc9e542</span>,<span class="number">0x0c9bcafc</span>,<span class="number">0x769bf209</span>,<span class="number">0x774664e8</span>,<span class="number">0x4d05f8b2</span>,<span class="number">0x7a1b0806</span>,<span class="number">0x5489330d</span>,<span class="number">0x572e6493</span>,<span class="number">0x36e62061</span>,<span class="number">0x1c979ef4</span>,<span class="number">0x53b95624</span>,<span class="number">0x7b87ba49</span>,<span class="number">0x4a02a315</span>,<span class="number">0x4b3ee601</span>,<span class="number">0x3fa44ad7</span>,<span class="number">0x529698ab</span>,<span class="number">0x5d6d5804</span>,<span class="number">0x18161018</span>,<span class="number">0x605146cf</span>,<span class="number">0x75be02e9</span>,<span class="number">0x5b2f51d5</span>,<span class="number">0x04c0fb96</span>,<span class="number">0x22f4fb33</span>,<span class="number">0x314403ca</span>,<span class="number">0x58e431f9</span>,<span class="number">0x488cbe2a</span>,<span class="number">0x6677855e</span>,<span class="number">0x771e54ea</span>,<span class="number">0x677e312d</span>,<span class="number">0x3a0f393c</span>,<span class="number">0x687fa594</span>,<span class="number">0x0548166f</span>,<span class="number">0x46ab0438</span>,<span class="number">0x5f1b979d</span>,<span class="number">0x7c8e7b58</span>,<span class="number">0x13b0fcea</span> &#125;;</span><br><span class="line"><span class="type">int</span> t1[] = &#123; <span class="number">33</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">32</span>,<span class="number">31</span>,<span class="number">10</span>,<span class="number">29</span>,<span class="number">9</span>,<span class="number">24</span>,<span class="number">26</span>,<span class="number">11</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">21</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ptr[<span class="number">38</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> final_flag[<span class="number">38</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ptr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">37</span>; i; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> v18 = t1[<span class="number">37</span>-i];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v19 = ptr[i];</span><br><span class="line">ptr[i] = ptr[v18];</span><br><span class="line">ptr[v18] = v19;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag[i] = enc[i] ^ arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag[i] ^= xor1[i];</span><br><span class="line">final_flag[ptr[i]] = (flag[i]&amp;<span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">final_flag[i] ^= xor[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, final_flag[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/image-20240531204507826.png" class="lazyload" data-srcset="/../image/image-20240531204507826.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240531204507826"></p><h2 id="rust-baby"><a href="#rust-baby" class="headerlink" title="rust_baby"></a>rust_baby</h2><p>首先我们要先找到这个函数</p><p>sub_7FF7B37F298A</p><p>这个函数相当于就是我们的主函数</p><p><img src="/../image/706.png" class="lazyload" data-srcset="/../image/706.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="706"></p><p>然后我们把memcpy的内容放到cyberchef里面解密，发现它一个字典的格式，这里面的信息对我们后面有用</p><p>这个函数就是输入函数</p><p><img src="/../image/707.png" class="lazyload" data-srcset="/../image/707.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="707"></p><p>我们注意到后面只处理八个字符，所以我就先输入8个字符</p><p>我们直接下个硬件断点，然后我们可以跟踪对字符串的处理</p><p><img src="/../image/708.png" class="lazyload" data-srcset="/../image/708.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="708"></p><p>由于这里的加密函数太复杂了，我们直接黑盒分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12345611  -------&gt;&gt;&gt;  01346733</span><br><span class="line">aabbccdd  -------&gt;&gt;&gt;  ``bbddff</span><br><span class="line">22334455  -------&gt;&gt;&gt;  11335577</span><br><span class="line">44556677  -------&gt;&gt;&gt;  33557799</span><br></pre></td></tr></table></figure><p>我们可以得到这个规律，后面还有个异或操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dic=-<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(enc),<span class="number">2</span>):</span><br><span class="line">    enc[i]+=dic</span><br><span class="line">    enc[i+<span class="number">1</span>]+=dic</span><br><span class="line">    dic+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc[i]^=<span class="number">0x33</span></span><br></pre></td></tr></table></figure><p>后面还有一个异或操作</p><p><img src="/../image/709.png" class="lazyload" data-srcset="/../image/709.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="709"></p><p>然后我们可以在这里提取出来我们需要异或的数值，但是我们怎么提取出真正的密钥呢，我们可以看到v91那里一共有104个字节，我们可以把这里全部设置成0</p><p>然后在后面可以提取出密钥，由于中间全部进行了base64加密操作，base64解密之后的就是真正的密钥</p><p><img src="/../image/710.png" class="lazyload" data-srcset="/../image/710.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="710"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">REAL_KEY =[<span class="number">0xdc</span>,<span class="number">0x5f</span>,<span class="number">0x20</span>,<span class="number">0x22</span>,<span class="number">0xc2</span>,<span class="number">0x79</span>,<span class="number">0x19</span>,<span class="number">0x56</span>,<span class="number">0x35</span>,<span class="number">0xda</span>,<span class="number">0x8b</span>,<span class="number">0x47</span>,<span class="number">0xd3</span>,<span class="number">0x19</span>,<span class="number">0xfc</span>,<span class="number">0x55</span>,<span class="number">0x14</span>,<span class="number">0xcd</span>,<span class="number">0xd2</span>,<span class="number">0x7b</span>,<span class="number">0x58</span>,<span class="number">0x59</span>,<span class="number">0x09</span>,<span class="number">0x42</span>,<span class="number">0xde</span>,<span class="number">0x2c</span>,<span class="number">0xb4</span>,<span class="number">0x48</span>,<span class="number">0xd9</span>,<span class="number">0xf2</span>,<span class="number">0x1b</span>,<span class="number">0xa9</span>,<span class="number">0x40</span>,<span class="number">0xe1</span>,<span class="number">0xa6</span>,<span class="number">0xfb</span>,<span class="number">0xff</span>,<span class="number">0x38</span>,<span class="number">0xc1</span>,<span class="number">0xd5</span>,<span class="number">0xe2</span>,<span class="number">0xe8</span>,<span class="number">0x77</span>,<span class="number">0x78</span>,<span class="number">0x6f</span>,<span class="number">0x22</span>,<span class="number">0x04</span>,<span class="number">0xe6</span>,<span class="number">0x16</span>,<span class="number">0x3e</span>,<span class="number">0x0c</span>,<span class="number">0x35</span>,<span class="number">0x52</span>,<span class="number">0x5c</span>,<span class="number">0xfd</span>,<span class="number">0xc1</span>,<span class="number">0xe5</span>,<span class="number">0x59</span>,<span class="number">0x1c</span>,<span class="number">0xd0</span>,<span class="number">0xae</span>,<span class="number">0x5a</span>,<span class="number">0xb2</span>,<span class="number">0xdd</span>,<span class="number">0x19</span>,<span class="number">0xf8</span>,<span class="number">0x42</span>,<span class="number">0xe6</span>,<span class="number">0x2c</span>,<span class="number">0x89</span>,<span class="number">0x59</span>,<span class="number">0xe5</span>,<span class="number">0x11</span>,<span class="number">0x9c</span>,<span class="number">0xc8</span>,<span class="number">0x7b</span>,<span class="number">0x81</span>,<span class="number">0x70</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0xbc</span>,<span class="number">0x6f</span>,<span class="number">0x02</span>,<span class="number">0x8f</span>,<span class="number">0xf7</span>,<span class="number">0xf4</span>,<span class="number">0xc8</span>,<span class="number">0x70</span>,<span class="number">0xae</span>,<span class="number">0x02</span>,<span class="number">0xf8</span>,<span class="number">0x5b</span>,<span class="number">0xe2</span>,<span class="number">0x72</span>,<span class="number">0x08</span>,<span class="number">0x09</span>,<span class="number">0x6f</span>,<span class="number">0xbf</span>,<span class="number">0x4b</span>,<span class="number">0x39</span>,<span class="number">0xb5</span>,<span class="number">0xd0</span>,<span class="number">0x1e</span>,<span class="number">0xa3</span>]</span><br><span class="line">enc=[<span class="number">0x8a</span>,<span class="number">0x07</span>,<span class="number">0x72</span>,<span class="number">0x76</span>,<span class="number">0x8d</span>,<span class="number">0x7d</span>,<span class="number">0x4d</span>,<span class="number">0x51</span>,<span class="number">0x35</span>,<span class="number">0xde</span>,<span class="number">0x88</span>,<span class="number">0x16</span>,<span class="number">0xd4</span>,<span class="number">0x04</span>,<span class="number">0xf9</span>,<span class="number">0x0e</span>,<span class="number">0x08</span>,<span class="number">0xcf</span>,<span class="number">0xcc</span>,<span class="number">0x7c</span>,<span class="number">0x0f</span>,<span class="number">0x0d</span>,<span class="number">0x09</span>,<span class="number">0x5e</span>,<span class="number">0xd5</span>,<span class="number">0x7e</span>,<span class="number">0xe4</span>,<span class="number">0x4b</span>,<span class="number">0xc4</span>,<span class="number">0xf3</span>,<span class="number">0x1c</span>,<span class="number">0xaf</span>,<span class="number">0x12</span>,<span class="number">0xe4</span>,<span class="number">0xa0</span>,<span class="number">0xae</span>,<span class="number">0xf6</span>,<span class="number">0x69</span>,<span class="number">0xc9</span>,<span class="number">0xd2</span>,<span class="number">0xe0</span>,<span class="number">0xa7</span>,<span class="number">0x01</span>,<span class="number">0x0e</span>,<span class="number">0x1a</span>,<span class="number">0x57</span>,<span class="number">0x70</span>,<span class="number">0x92</span>,<span class="number">0x61</span>,<span class="number">0x49</span>,<span class="number">0x7a</span>,<span class="number">0x43</span>,<span class="number">0x27</span>,<span class="number">0x29</span>,<span class="number">0x89</span>,<span class="number">0xb5</span>,<span class="number">0x92</span>,<span class="number">0x2e</span>,<span class="number">0x6a</span>,<span class="number">0xa6</span>,<span class="number">0xdb</span>,<span class="number">0x2f</span>,<span class="number">0xc6</span>,<span class="number">0xa9</span>,<span class="number">0x6e</span>,<span class="number">0x8f</span>,<span class="number">0x34</span>,<span class="number">0x90</span>,<span class="number">0x59</span>,<span class="number">0xfc</span>,<span class="number">0x2d</span>,<span class="number">0x91</span>,<span class="number">0x66</span>,<span class="number">0xeb</span>,<span class="number">0xbe</span>,<span class="number">0x0d</span>,<span class="number">0xf4</span>,<span class="number">0x05</span>,<span class="number">0x0b</span>,<span class="number">0x1b</span>,<span class="number">0xcb</span>,<span class="number">0x18</span>,<span class="number">0x74</span>,<span class="number">0xf9</span>,<span class="number">0x82</span>,<span class="number">0x81</span>,<span class="number">0xbc</span>,<span class="number">0x04</span>,<span class="number">0xd9</span>,<span class="number">0x75</span>,<span class="number">0x8e</span>,<span class="number">0x2d</span>,<span class="number">0x97</span>,<span class="number">0x07</span>,<span class="number">0x7c</span>,<span class="number">0x7d</span>,<span class="number">0x18</span>,<span class="number">0xc8</span>,<span class="number">0x3d</span>,<span class="number">0x4f</span>,<span class="number">0xc0</span>,<span class="number">0xa5</span>,<span class="number">0x6a</span>,<span class="number">0xd7</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(REAL_KEY)):</span><br><span class="line">    enc[i]^=REAL_KEY[i]</span><br><span class="line">    enc[i]^=<span class="number">0x33</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">   num1=-<span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>,<span class="number">2</span>):</span><br><span class="line">       enc[<span class="number">8</span>*i+j]-=num1</span><br><span class="line">       enc[<span class="number">8</span>*i+j+<span class="number">1</span>]-=num1</span><br><span class="line">       num1+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span>  i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc[i]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#flag&#123;6e2480b3-4f02-4cf1-9bc0-123b75f9a922&#125;</span></span><br></pre></td></tr></table></figure><h2 id="GoReverse"><a href="#GoReverse" class="headerlink" title="GoReverse"></a>GoReverse</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>这里借鉴的思路是panda0s师傅的思路</p><p><a href="https://www.bilibili.com/video/BV1bJ4m1w767/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=f5a24deea97cc11fbdd53a993a4129bf">https://www.bilibili.com/video/BV1bJ4m1w767/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f5a24deea97cc11fbdd53a993a4129bf</a></p><p><img src="/../image/667.png" class="lazyload" data-srcset="/../image/667.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="667"></p><p>发现没有符号表，我们可以先恢复一下符号表</p><p><a href="https://github.com/0xjiayu/go_parser">https://github.com/0xjiayu/go_parser</a><br>克隆仓库，IDA加载go_parser.py即可，不需要把脚本放到plugin里面</p><p><img src="/../image/668.png" class="lazyload" data-srcset="/../image/668.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="668"></p><p>初始化在runtime_main里面，然后我们的主函数在main__B2bUPq_Execute里面</p><p>里面一共有两个反调试的地方</p><p><img src="/../image/669.png" class="lazyload" data-srcset="/../image/669.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="669"></p><p>在调用这个runtime_systemstack之后就会退出，我们可以把这个nop掉</p><p><img src="/../image/670.png" class="lazyload" data-srcset="/../image/670.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="670"></p><p>第二个反调试就很明显了，在地址0x004D64A0 这里</p><p>把他patch掉就行了</p><p><img src="/../image/671.png" class="lazyload" data-srcset="/../image/671.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="671"></p><p>后面的zQyveE为xxtea加密，我们可以把ToUint32s复制下来</p><p><a href="https://github.com/xxtea/xxtea-go/blob/master/xxtea/xxtea.go">https://github.com/xxtea/xxtea-go/blob/master/xxtea/xxtea.go</a></p><p><img src="/../image/672.png" class="lazyload" data-srcset="/../image/672.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="672"></p><p>我们可以发现xxtea进行了魔改，魔改的地方为MX和delta</p><p>然后我们可以在以下几个地方设置断点</p><p><img src="/../image/673.png" class="lazyload" data-srcset="/../image/673.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="673"></p><p><img src="/../image/674.png" class="lazyload" data-srcset="/../image/674.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="674"></p><p>然后我们可以先在进行异或操作之前下个断点</p><p><img src="/../image/675.png" class="lazyload" data-srcset="/../image/675.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="675"></p><p>因为我是之前先异或了，所以再异或一下就回去了，这样便于我们更好分析</p><p>以下是我们异或的值</p><p><img src="/../image/676.png" class="lazyload" data-srcset="/../image/676.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="676"></p><p>我们经过xxtea加密之后我们看一下它的返回值</p><p><img src="/../image/677.png" class="lazyload" data-srcset="/../image/677.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="677"></p><p>一共十六个字节，很明显是我们的输入之后的加密结果，但是我们便于分析统一变成11，这个时候我们就可以直接按F9</p><p>跳到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004D5D41 call    github_com_tjfoc_gmsm_sm4_NewCipher</span><br></pre></td></tr></table></figure><p><img src="/../image/678.png" class="lazyload" data-srcset="/../image/678.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="678"></p><p>然后这个时候我们可以得到SM4的密钥</p><p>继续往下面调</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004D5D96 call    crypto_rand_Read</span><br></pre></td></tr></table></figure><p>这是生成的随机数</p><p><img src="/../image/679.png" class="lazyload" data-srcset="/../image/679.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="679"></p><p>我们统一把它设成22</p><p>再继续往下面调，一直到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004D5DEF call   rdx 其实调用的是crypto_cipher__ctr_XORKeyStream</span><br></pre></td></tr></table></figure><p>然后我们在rsi寄存器得到了我们一开始经过xxtea加密的密文</p><p>这个时候要和sm4生成的密文(CTR模式)进行异或</p><p>但是这个iv是随机生成的（后面会解释这个怎么得到）</p><p>继续往下面调我们可以到到aes的密钥</p><p><img src="/../image/680.png" class="lazyload" data-srcset="/../image/680.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="680"></p><p>再往下面走，我们可以得到aes的iv是key的前16位</p><p>我们在最后retn这里下个断点，我们把前16位的全都替换成33，最后在Linux里面会输出一段base32的字符串</p><p><img src="/../image/681.png" class="lazyload" data-srcset="/../image/681.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="681"></p><p><img src="/../image/683.png" class="lazyload" data-srcset="/../image/683.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="683"></p><p><img src="/../image/682.png" class="lazyload" data-srcset="/../image/682.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="682"></p><p>就是我们最后输入的33，那么说明我们在经过base32和aes解密之后，得到的前16个字节就是sm4随机生成的iv</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>这里为了复现我直接借用了其它师傅在比赛中得到的flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;3a4575cf-c85c-4350-90ca-baef825242&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/686.png" class="lazyload" data-srcset="/../image/686.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="686"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">enc=<span class="string">b&#x27;HAA4WOBVE4J2GIVLNOAXSN3N2L3UCBWPZJJICPWEVNYREBHRPGFGIT43WJENRUU25HKVMEMU7QRKDOZWADY7WOK2JAF7J7DOSZ652EY=&#x27;</span></span><br><span class="line"></span><br><span class="line">enc=base64.b32decode(enc)</span><br><span class="line"></span><br><span class="line">aeskey=<span class="string">b&#x27;dPGWgcLpqmxw3uOXhKpKV009Cql@@XE6&#x27;</span></span><br><span class="line">aesiv =<span class="string">b&#x27;dPGWgcLpqmxw3uOXhKpKV009Cql@@XE6&#x27;</span>[:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">enc=AES.new(key=aeskey,iv=aesiv,mode=AES.MODE_CBC).decrypt(enc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(enc[:<span class="number">16</span>].<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure><p>根据flag长度为40或42可知counter还需要分别+1和+2，总共3*16bytes</p><p><img src="/../image/685.png" class="lazyload" data-srcset="/../image/685.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="685"></p><p>我们将SM4加密的密文与AES解出来的明文的从第16位开始进行异或，解出来的就是xxtea的密文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctr=<span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;7c aa 04 c3 57 63 29 c3 eb 24 34 4f cf 3e 00 88 7b 60 85 f1 45 88 35 17 52 2c 72 1e 8e cf cf c9 fa 03 9e 45 0f f9 7c 05 d7 e6 b0 3a 8c 0b 09 43 11 ba e2 41 45 1c e9 f6 ea 51 52 63 f5 41 5b 29&#x27;</span>)</span><br><span class="line">enc=<span class="built_in">list</span>(enc[<span class="number">16</span>:])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc[i]^=ctr[i]</span><br><span class="line">enc=<span class="built_in">bytes</span>(enc)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(enc), <span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, enc[i:i+<span class="number">4</span>])[<span class="number">0</span>]), end=<span class="string">&quot;,&quot;</span>) <span class="comment">#变成32位，便于后面进行xxtea解密</span></span><br></pre></td></tr></table></figure><p>之后进行xxtea加密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX ((((z&gt;&gt;5 ^ y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3 ^ z&lt;&lt;4)) ^ (sum^y)) + (key[(p&amp;3)^e]^z))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x7FAB4CAD</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xxtea</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* v, <span class="type">unsigned</span> <span class="type">int</span>* key, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> y, z, sum;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p, e, round;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">round = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">z = v[n - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (round--)</span><br><span class="line">&#123;</span><br><span class="line">sum += DELTA;</span><br><span class="line">e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++)</span><br><span class="line">&#123;</span><br><span class="line">y = v[p + <span class="number">1</span>];</span><br><span class="line">v[p] += MX;</span><br><span class="line">z = v[p];</span><br><span class="line">&#125;</span><br><span class="line">y = v[<span class="number">0</span>];</span><br><span class="line">v[n - <span class="number">1</span>] += MX;</span><br><span class="line">z = v[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">n = -n;</span><br><span class="line">round = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">sum = DELTA * round;</span><br><span class="line">y = v[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span> (round--)</span><br><span class="line">&#123;</span><br><span class="line">e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; p--)</span><br><span class="line">&#123;</span><br><span class="line">z = v[p - <span class="number">1</span>];</span><br><span class="line">v[p] -= MX;</span><br><span class="line">y = v[p];</span><br><span class="line">&#125;</span><br><span class="line">z = v[n - <span class="number">1</span>];</span><br><span class="line">v[<span class="number">0</span>] -= MX;</span><br><span class="line">y = v[<span class="number">0</span>];</span><br><span class="line">sum -= DELTA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> xorr[] = <span class="string">&quot;D7BJLsOk9@f&amp;1dWIn53IDlJqUS6$^WhkAk2kk*2GaqmLwiLX^bGGE$&amp;dmqR^g5bL3lCA5^HGK$9qo5T@Bwom9vEXya0HAV3LrWW&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> keybyte[] = <span class="string">&quot;Bs^8*wZ4lu8oR&amp;@k&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* key = (<span class="type">unsigned</span> <span class="type">int</span>*)keybyte;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> text[] = &#123; <span class="number">0x14e89d7c</span>,<span class="number">0x70624924</span>,<span class="number">0xe0a2078c</span>,<span class="number">0x555d91e</span>,<span class="number">0xcdd3602</span>,<span class="number">0x6bc8c9d6</span>,<span class="number">0x975e0d09</span>,<span class="number">0x5a54d90f</span>,<span class="number">0xafc1d576</span>,<span class="number">0x73f7f1b2</span>,<span class="number">0x32b8eedf</span>,<span class="number">0x4b010384</span> &#125;;</span><br><span class="line">xxtea(text, key, <span class="number">-10</span>);</span><br><span class="line"><span class="type">char</span>* enc = (<span class="type">char</span>*)text;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i++)</span><br><span class="line">enc[i] ^= xorr[i % <span class="built_in">strlen</span>(xorr)];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, enc[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/687.png" class="lazyload" data-srcset="/../image/687.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="687"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;asm-re&quot;&gt;&lt;a href=&quot;#asm-re&quot; class=&quot;headerlink&quot; title=&quot;asm_re&quot;&gt;&lt;/a&gt;asm_re&lt;/h2&gt;&lt;p&gt;直接手撕汇编&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../image/688.png&quot; class=&quot;lazy</summary>
      
    
    
    
    <category term="WP" scheme="https://5m10v3.github.io/categories/WP/"/>
    
    
    <category term="ctf学习" scheme="https://5m10v3.github.io/tags/ctf%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>日记(23)</title>
    <link href="https://5m10v3.github.io/2024/05/12/%E6%97%A5%E8%AE%B0(23)/"/>
    <id>https://5m10v3.github.io/2024/05/12/%E6%97%A5%E8%AE%B0(23)/</id>
    <published>2024-05-11T16:00:00.000Z</published>
    <updated>2024-05-12T13:15:35.779Z</updated>
    
    <content type="html"><![CDATA[<p>编写那个pe病毒没有成功，主要是在添加完一个新节地址没有对齐<br>感觉这几天都比较浑浑噩噩，不能再这样下去了，要重新振作起来</p><p>感觉对好几个方向都搞的话，更加的迷茫了，目前还是要学一些实际的东西</p><ul><li>LLVM的初步学习</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编写那个pe病毒没有成功，主要是在添加完一个新节地址没有对齐&lt;br&gt;感觉这几天都比较浑浑噩噩，不能再这样下去了，要重新振作起来&lt;/p&gt;
&lt;p&gt;感觉对好几个方向都搞的话，更加的迷茫了，目前还是要学一些实际的东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LLVM的初步学习&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    <category term="日记" scheme="https://5m10v3.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>PE文件格式解析</title>
    <link href="https://5m10v3.github.io/2024/05/10/[%E9%80%86%E5%90%91]PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <id>https://5m10v3.github.io/2024/05/10/[%E9%80%86%E5%90%91]PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</id>
    <published>2024-05-09T16:00:00.000Z</published>
    <updated>2024-05-10T14:21:16.559Z</updated>
    
    <content type="html"><![CDATA[<p>下图是PE文件格式示意图<br><img src="/2024/05/10/[逆向]PE文件格式解析/image" class="lazyload" data-srcset="/2024/05/10/[逆向]PE文件格式解析/image" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="  alt="660" style="zoom:67%;" /></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>首先在这里说明一个概念，可执行文件(Executable File)是指可以由操作系统直接加载的文件，在Windows操作系统中可执行文件就是PE文件结构，在Linux下则是ELF文件，我们这里只讨论Windows下的PE文件，要了解PE文件，首先要知道PE格式，那么什么是PE格式呢，既然是一个格式，那肯定是我们都需要遵循的定理</p><p>其实PE格式就是各种结构体的结合，Windows下PE文件的各种结构体在WinNT.h这个头文件中，可以在VS中查询。</p><h3 id="PE文件整体结构"><a href="#PE文件整体结构" class="headerlink" title="PE文件整体结构"></a>PE文件整体结构</h3><p>PE结构可以大致分为:</p><ul><li>DOS部分</li><li>PE文件头</li><li>节表(块表)</li><li>节数据(块数据)</li><li>调试信息</li></ul><h3 id="PE指纹"><a href="#PE指纹" class="headerlink" title="PE指纹"></a>PE指纹</h3><p>PE指纹是什么呢?其实就是跟我们现实生活中的指纹一样，为了识别一些东西，我们可以通过它来判断是否为一个有效的PE文件。</p><p>分析其结构，首先是根据文件的前两个字节是否为4D 5A，也就是’MZ’，然后看第四排四个字节指向的地址00 00 00 f0是否为50 45，也就是’PE’，满足这两个条件也就满足了PE文件的格式.</p><p><img src="/../image/655.png" class="lazyload" data-srcset="/../image/655.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="655"></p><h3 id="DOS部分"><a href="#DOS部分" class="headerlink" title="DOS部分"></a>DOS部分</h3><p>DOS部分主要是为了兼容以前的DOS系统，DOS部分可以分为DOS MZ文件头(IMAGE_DOS_HEADER)和DOS块(DOS Stub)组成，PE文件的第一个字节位于一个传统的MS-DOS头部，称作IMAGE_DOS_HEADER，其结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header</span><br><span class="line">    WORD   e_magic;                     // Magic number</span><br><span class="line">    WORD   e_cblp;                      // Bytes on last page of file</span><br><span class="line">    WORD   e_cp;                        // Pages in file</span><br><span class="line">    WORD   e_crlc;                      // Relocations</span><br><span class="line">    WORD   e_cparhdr;                   // Size of header in paragraphs</span><br><span class="line">    WORD   e_minalloc;                  // Minimum extra paragraphs needed</span><br><span class="line">    WORD   e_maxalloc;                  // Maximum extra paragraphs needed</span><br><span class="line">    WORD   e_ss;                        // Initial (relative) SS value</span><br><span class="line">    WORD   e_sp;                        // Initial SP value</span><br><span class="line">    WORD   e_csum;                      // Checksum</span><br><span class="line">    WORD   e_ip;                        // Initial IP value</span><br><span class="line">    WORD   e_cs;                        // Initial (relative) CS value</span><br><span class="line">    WORD   e_lfarlc;                    // File address of relocation table</span><br><span class="line">    WORD   e_ovno;                      // Overlay number</span><br><span class="line">    WORD   e_res[4];                    // Reserved words</span><br><span class="line">    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)</span><br><span class="line">    WORD   e_oeminfo;                   // OEM information; e_oemid specific</span><br><span class="line">    WORD   e_res2[10];                  // Reserved words</span><br><span class="line">    LONG   e_lfanew;                    // File address of new exe header</span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>我们只需要熟悉的是 e_magic 和 e_lfanew 这两部分，前者是标识PE指纹的一部分，后者则是寻找PE文件头的部分，其它部分全部填0，也不会影响程序运行</p><p><img src="/../image/656.png" class="lazyload" data-srcset="/../image/656.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="656"></p><p>上图是Dos部分</p><p>我们可以看到e_lfanew指向PE文件头，我们可以通过它来寻找PE文件头，而DOS块的部分自然就是PE文件头和DOS MZ文件头中间的部分，这部分是由链接器所写入的，可以随意进行修改，并不影响程序的运行：</p><p><img src="/../image/657.png" class="lazyload" data-srcset="/../image/657.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="657"></p><h3 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h3><p>PE文件头由PE文件头标志，标准PE头，扩展PE头三部分组成。PE文件头标志自然是50 40 00 00，也就是’PE’，我们从结构体的角度看一下PE文件头的详细信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature; <span class="comment">//PE文件头标志 =&gt; 4字节</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader; <span class="comment">//标准PE头 =&gt; 20字节</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">//扩展PE头 =&gt; 32位下224字节(0xE0) 64位下240字节(0xF0)</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p><img src="/../image/658.png" class="lazyload" data-srcset="/../image/658.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="658"></p><p>标黄的地方就是pe文件头的位置</p><p>下图划线部分为PE文件标志</p><p><img src="/../image/659.png" class="lazyload" data-srcset="/../image/659.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="659"></p><p>后面二十个字节为PE标准头，一直到10B之前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine; <span class="comment">//可以运行在什么平台上 任意:0 ,Intel 386以及后续:14C x64:8664</span></span><br><span class="line">    WORD    NumberOfSections; <span class="comment">//节的数量</span></span><br><span class="line">    DWORD   TimeDateStamp; <span class="comment">//编译器填写的时间戳</span></span><br><span class="line">    DWORD   PointerToSymbolTable;   <span class="comment">//调试相关</span></span><br><span class="line">    DWORD   NumberOfSymbols; <span class="comment">//调试相关</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;   <span class="comment">//标识扩展PE头大小</span></span><br><span class="line">    WORD    Characteristics;        <span class="comment">//文件属性 =&gt; 16进制转换为2进制根据哪些位有1,可以查看相关属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p><img src="/../image/661.png" class="lazyload" data-srcset="/../image/661.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="661"></p><p>拓展PE头大小在32位和64位是不一样的，下图为32位系统</p><p><img src="/../image/662.png" class="lazyload" data-srcset="/../image/662.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="662"></p><p>我们可以注意到是0xF0，而32位是0xE0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    //</span><br><span class="line">    // Standard fields.</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">    WORD    Magic;//PE32: 10B PE64: 20B</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;//所有含有代码的区块的大小 编译器填入 没用(可改)</span><br><span class="line">    DWORD   SizeOfInitializedData;//所有初始化数据区块的大小 编译器填入 没用(可改)</span><br><span class="line">    DWORD   SizeOfUninitializedData;//所有含未初始化数据区块的大小 编译器填入 没用(可改)</span><br><span class="line">    DWORD   AddressOfEntryPoint;//程序入口RVA</span><br><span class="line">    DWORD   BaseOfCode;//代码区块起始RVA</span><br><span class="line">    DWORD   BaseOfData;//数据区块起始RVA</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // NT additional fields.</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;//内存镜像基址(程序默认载入基地址)</span><br><span class="line">    DWORD   SectionAlignment; //内存中对齐大小</span><br><span class="line">    DWORD   FileAlignment; //文件中对齐大小(提高程序运行效率)</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;//内存中整个PE文件的映射的尺寸,可比实际值大,必须是SectionAlignment的整数倍</span><br><span class="line">    DWORD   SizeOfHeaders; //所有的头加上节表文件对齐之后的值</span><br><span class="line">    DWORD   CheckSum;//映像校验和,一些系统.dll文件有要求,判断是否被修改</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;//文件特性,不是针对DLL文件的,16进制转换2进制可以根据属性对应的表格得到相应的属性</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //数据目录表,结构体数组</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>这里总结一点：程序的真正入口点是 &#x3D; imageBase + AddressEntryPoint</p><h3 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h3><p>节表的结构如下，整体为40个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; //ASCII字符串 可自定义 只截取8个字节</span><br><span class="line">    union &#123;   //该节在没有对齐之前的真实尺寸,该值可以不准确</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;    //内存中的偏移地址</span><br><span class="line">    DWORD   SizeOfRawData;   //节在文件中对齐的尺寸</span><br><span class="line">    DWORD   PointerToRawData;   //节区在文件中的偏移</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;   //节的属性</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>程序中显示如下（蓝色部分）</p><p><img src="/../image/663.png" class="lazyload" data-srcset="/../image/663.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="663"></p><p>得注意的是扩展PE头中的 FileAlignment 以及 SizeOfHeaders 这两个成员，SizeOfHeaders 表示所有的头加上节表文件对齐之后的值，对齐的大小参考的就是 FileAlignment 成员，如果所有的头加上节表的大小为320，FileAlignment 为 200，那么 SizeOfHeaders 大小就为 400，因为是根据FileAlignment 对齐的，这种对齐虽然牺牲了空间，但是可以提高程序运行效率，下图中的前面部分0x00100000就是程序在内存中对齐的大小，也就是程序运行起来时对齐的大小，0x00000400是程序在文件中的对齐大小，也就是没有运行时对齐的大小，需要清楚的是，PE程序在运行时内存中的对齐值和没有运行时的对齐值可能是截然不同的</p><h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>导出表(Import Table)和导入表是靠 IMAGE_DATA_DIRECTORY 这个结构体数组来寻找的，IMAGE_DATA_DIRECTORY 的结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>导入表的结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD   Characteristics;            // 0 for terminating null import descriptor</span><br><span class="line">        DWORD   OriginalFirstThunk;         // RVA 指向 INT (PIMAGE_THUNK_DATA结构数组)</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  // 0 if not bound,</span><br><span class="line">                                            // -1 if bound, and real date\time stamp</span><br><span class="line">                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br><span class="line">                                            // O.W. date/time stamp of DLL bound to (Old BIND)</span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 // -1 if no forwarders</span><br><span class="line">    DWORD   Name;//RVA指向dll名字,以0结尾</span><br><span class="line">    DWORD   FirstThunk;                     // RVA 指向 IAT (PIMAGE_THUNK_DATA结构数组)</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line">typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR</span><br></pre></td></tr></table></figure><p>一个程序导入多少库就存在多少个Image_Import_Descripotor结构体.结构体数组最后以NULL结构体结束.</p><p>有以下重要成员(全部都是相对虚拟地址):</p><p><strong>1#.OriginalFirstThunk</strong></p><p><strong>INT</strong>(Import Name Table)的地址.INT中各个元素的值为Image_Import_By_Name<strong>结构体指针.INT和IAT的大小相同,且都是长整型(4字节数据类型)数组.</strong></p><p><strong>2#.Name</strong></p><p><strong>库名称</strong>字符串的<strong>地址</strong>.</p><p><strong>3#.FirstThunk</strong></p><p><strong>IAT</strong>的<strong>地址.</strong></p><p><img src="/../image/664.png" class="lazyload" data-srcset="/../image/664.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="664"></p><p>上图只是PE文件加载前的情况，PE文件一旦运行起来，就会变成下图的情况</p><p><img src="/../image/665.png" class="lazyload" data-srcset="/../image/665.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="665"></p><p>我们还需要了解的结构体是 IMAGE_THUNK_DATA 和 IMAGE_IMPORT_BY_NAME 结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_BY_NAME &#123;</span><br><span class="line">    WORD    Hint; //可能为空,编译器决定,如果不为空,是函数在导出表的索引</span><br><span class="line">    BYTE    Name[1]; //函数名称,以0结尾</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br><span class="line"></span><br><span class="line">#include &quot;pshpack8.h&quot;                       // Use align 8 for the 64-bit IAT.</span><br><span class="line"></span><br><span class="line">typedef struct _IMAGE_THUNK_DATA64 &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        ULONGLONG ForwarderString;  // 指向一个转向者字符串的RVA</span><br><span class="line">        ULONGLONG Function;         // 被输入的函数的内存地址</span><br><span class="line">        ULONGLONG Ordinal;// 被输入API的序数值</span><br><span class="line">        ULONGLONG AddressOfData;    // 指针指向 IMAGE_IMPORT_BY_NAME</span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA64;</span><br><span class="line">typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;</span><br><span class="line"></span><br><span class="line">#include &quot;poppack.h&quot;                        // Back to 4 byte packing</span><br><span class="line"></span><br><span class="line">typedef struct _IMAGE_THUNK_DATA32 &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD ForwarderString;      // PBYTE </span><br><span class="line">        DWORD Function;             // PDWORD</span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME</span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line">typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><p>其实他们的作用很明显，就是用来寻找当前的模块依赖哪些函数，可以用这几个结构体求到依赖函数的名字。</p><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><p>导出表(Export Table)一般是DLL文件用的比较多，exe文件很少有导出表，导出表的数据结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;// 指针指向该导出表文件名字符串</span><br><span class="line">    DWORD   Base;// 导出函数起始序号</span><br><span class="line">    DWORD   NumberOfFunctions;// 所有导出函数的个数</span><br><span class="line">    DWORD   NumberOfNames;// 以函数名字导出的函数个数</span><br><span class="line">    DWORD   AddressOfFunctions;     // 指针指向导出函数地址表RVA</span><br><span class="line">    DWORD   AddressOfNames;         // 指针指向导出函数名称表RVA</span><br><span class="line">    DWORD   AddressOfNameOrdinals;  // 指针指向导出函数序号表RVA</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>可以看到导出表里面最后还有三个表，这三个表可以让我们找到函数真正的地址，在编写PE格式解析器的时候可以用到，AddressOfFunctions 是函数地址表，指向每个函数真正的地址，AddressOfNames 和 AddressOfNameOrdinals 分别是函数名称表和函数序号表，我们知道DLL文件有两种调用方式，一种是用名字，一种是用序号，通过这两个表可以用来寻找函数在 AddressOfFunctions 表中真正的地址。</p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>当PE文件被装载到虚拟内存的另一个地址中的时候，也就是载入时不将默认的值作为基地址载入，链接器登记的哪个地址是错误的，需要我们用重定位表来调整，重定位表在数据目录项的第 6 个结构，结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_BASE_RELOCATION &#123;</span><br><span class="line">    DWORD   VirtualAddress; // 重定位数据的开始 RVA 地址</span><br><span class="line">    DWORD   SizeOfBlock;// 重定位块的长度</span><br><span class="line">//  WORD    TypeOffset[1];// 重定位项数组</span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line">typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><p>重定位表有许多个，以八个字节的 0 结尾</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从写这个简单PE文件解释器学到了很多好玩的东西</p><ul><li>win32API</li></ul><p>通过编写这个简单的PE文件解释器真的对pe文件的理解更加深了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取虚拟地址的偏移</span></span><br><span class="line">DWORD <span class="title function_">RVAOffset</span><span class="params">(PIMAGE_NT_HEADERS pNtHeader, DWORD Rva)</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)IMAGE_FIRST_SECTION(pNtHeader);<span class="comment">//获得首地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD SectionBeginRva = pSectionHeader[i].VirtualAddress;</span><br><span class="line"></span><br><span class="line">DWORD SectionEndRva = pSectionHeader[i].VirtualAddress + pSectionHeader[i].SizeOfRawData;</span><br><span class="line"><span class="keyword">if</span> (Rva &gt;= SectionBeginRva &amp;&amp; Rva &lt;= SectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">DWORD Temp = Rva - SectionBeginRva;</span><br><span class="line">DWORD Rwa = Temp + pSectionHeader[i].PointerToRawData;<span class="comment">//计算它在节表里面的偏移</span></span><br><span class="line"><span class="keyword">return</span> Rwa;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE hFile; <span class="comment">//创造句柄</span></span><br><span class="line">HANDLE hMapping;</span><br><span class="line">LPVOID ImageBase;</span><br><span class="line"><span class="type">char</span> szFilePath[MAX_PATH];</span><br><span class="line">OPENFILENAME ofn;<span class="comment">//定义结构，调用文件对话框选择要分析的文件及其保存路径</span></span><br><span class="line">PIMAGE_DOS_HEADER pDH = <span class="literal">NULL</span>; <span class="comment">//指向IMAGE_DOS结构的指针</span></span><br><span class="line">PIMAGE_NT_HEADERS pNtH = <span class="literal">NULL</span>; <span class="comment">//指向IMAGE_NT结构的指针</span></span><br><span class="line">PIMAGE_FILE_HEADER pFH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_FILE结构的指针</span></span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_OPTIONAL结构的指针</span></span><br><span class="line">    <span class="built_in">memset</span>(szFilePath, <span class="number">0</span>, MAX_PATH);</span><br><span class="line"><span class="built_in">memset</span>(&amp;ofn, <span class="number">0</span>, <span class="keyword">sizeof</span>(ofn));</span><br><span class="line">ofn.lStructSize = <span class="keyword">sizeof</span>(ofn);</span><br><span class="line">ofn.hwndOwner = <span class="literal">NULL</span>;</span><br><span class="line">ofn.hInstance = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">ofn.nMaxFile = MAX_PATH;</span><br><span class="line">ofn.lpstrInitialDir = <span class="string">&quot;.&quot;</span>;</span><br><span class="line">ofn.lpstrFile = szFilePath;</span><br><span class="line">ofn.lpstrTitle = <span class="string">&quot;请选择的文件路径&quot;</span>;</span><br><span class="line">ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;</span><br><span class="line">ofn.lpstrFilter = <span class="string">&quot;*.*\0*.*\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!GetOpenFileName(&amp;ofn))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件错误:%d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">hFile = CreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!hFile)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>,szFilePath,<span class="string">&quot;File opened failed&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line">hMapping = CreateFileMapping(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!hMapping)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建映射错误:%d&quot;</span>, GetLastError());</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得基址</span></span><br><span class="line">ImageBase = MapViewOfFile(hMapping, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ImageBase)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件映射错误:%d&quot;</span>, GetLastError());</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************** PE头的判断 *********************************/</span></span><br><span class="line"><span class="keyword">if</span> (!ImageBase)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Not a valid PE file error1!\n&quot;</span>);</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&lt;--------------------------PEheader-------------------------------&gt;\n&quot;</span>);</span><br><span class="line">pDH = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line"><span class="keyword">if</span> (pDH-&gt;e_magic != IMAGE_DOS_SIGNATURE) <span class="comment">//判断是否为MZ</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Not a valid PE file error2!\n&quot;</span>);</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">pNtH = (PIMAGE_NT_HEADERS)((DWORD)pDH + pDH-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">if</span> (pNtH-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Not a valid PE file error3!\n&quot;</span>);</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PE e_lfanew is: 0x%x\n&quot;</span>,pNtH);</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/*  FileHeader                                */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line">pFH = &amp;pNtH-&gt;FileHeader;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------------FileHeader------------------------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NumberOfSections:%d\n&quot;</span>, pFH-&gt;NumberOfSections); <span class="comment">//节的数量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SizeOfOptionalHeader:%d\n&quot;</span>, pFH-&gt;SizeOfOptionalHeader); <span class="comment">//PE头的大小</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/*  OptionalHeader                            */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line">pOH = &amp;pNtH-&gt;OptionalHeader;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-----------------OptionalHeader---------------------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SizeOfCode:0x%08x\n&quot;</span>, pOH-&gt;SizeOfCode);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;AddressOfEntryPoint: 0x%08X\n&quot;</span>, pOH-&gt;AddressOfEntryPoint);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ImageBase is 0x%x\n&quot;</span>, ImageBase);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SectionAlignment: 0x%08x\n&quot;</span>, pOH-&gt;SectionAlignment);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;FileAlignment: 0x%08x\n&quot;</span>, pOH-&gt;FileAlignment);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SizeOfImage: 0x%08x\n&quot;</span>, pOH-&gt;SizeOfImage);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SizeOfHeaders: 0x%08x\n&quot;</span>, pOH-&gt;SizeOfHeaders);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NumberOfRvaAndSizes: 0x%08x\n&quot;</span>, pOH-&gt;NumberOfRvaAndSizes);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/*  SectionTable                              */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="type">int</span> SectionNumber = <span class="number">0</span>;</span><br><span class="line">DWORD SectionHeaderOffset = (DWORD)pNtH + <span class="number">24</span> + (DWORD)pFH-&gt;SizeOfOptionalHeader;<span class="comment">//节表位置的计算</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------------------SectionTable---------------------\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (SectionNumber; SectionNumber &lt; pFH-&gt;NumberOfSections; SectionNumber++)</span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_SECTION_HEADER pSh = (PIMAGE_SECTION_HEADER)(SectionHeaderOffset + <span class="number">40</span> * SectionNumber);  <span class="comment">//一个节表大小为40个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &#x27;s Name is %s\n&quot;</span>, SectionNumber + <span class="number">1</span>, pSh-&gt;Name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;VirtualAddress: 0x%08X\n&quot;</span>, (DWORD)pSh-&gt;VirtualAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SizeOfRawData: 0x%08X\n&quot;</span>, (DWORD)pSh-&gt;SizeOfRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PointerToRawData: 0x%08X\n&quot;</span>, (DWORD)pSh-&gt;PointerToRawData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/*  ExportTable                               */</span><span class="comment">//导出表/</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------------------ExportTable----------------------\n&quot;</span>);</span><br><span class="line">DWORD Export_table_offset = RVAOffset(pNtH, (DWORD)pNtH-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD)ImageBase + Export_table_offset);</span><br><span class="line">DWORD EXport_table_offset_Name = (DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;Name);</span><br><span class="line">DWORD* pNameOfAddress = (DWORD*)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNames));</span><br><span class="line">DWORD* pFunctionOfAdress = (DWORD*)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfFunctions));</span><br><span class="line">WORD* pNameOrdinalOfAddress = (WORD*)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNameOrdinals));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name:%s\n&quot;</span>, EXport_table_offset_Name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NameOfAddress:%08X\n&quot;</span>, RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNames));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;FunctionOfAdress:%08X\n&quot;</span>, RVAOffset(pNtH, pExportDirectory-&gt;AddressOfFunctions));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NameOrdinalOfAddress:%08X\n&quot;</span>, RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNameOrdinals));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pExportDirectory-&gt;NumberOfFunctions == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;!!!!!!!!!!!!!!!!!NO EXPORT!!!!!!!!!!!!!!!!!!!!!&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hMapping != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImageBase != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">UnmapViewOfFile(ImageBase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NumberOfNames:%d\n&quot;</span>, pExportDirectory-&gt;NumberOfNames);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NumberOfFunctions:%d\n&quot;</span>, pExportDirectory-&gt;NumberOfFunctions);</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/*  ImportTable                               */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------------------ImportTable----------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cont = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dwImportOffset = RVAOffset(pNtH, pNtH-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">dwImportOffset = dwImportOffset + cont;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)ImageBase + dwImportOffset);</span><br><span class="line"><span class="keyword">if</span> (pImport-&gt;OriginalFirstThunk == <span class="number">0</span> &amp;&amp; pImport-&gt;TimeDateStamp == <span class="number">0</span> &amp;&amp; pImport-&gt;ForwarderChain == <span class="number">0</span> &amp;&amp; pImport-&gt;Name == <span class="number">0</span> &amp;&amp; pImport-&gt;FirstThunk == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">DWORD dwOriginalFirstThunk = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;OriginalFirstThunk);</span><br><span class="line">DWORD dwFirstThunk = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;FirstThunk);</span><br><span class="line">DWORD dwName = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;Name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;---------Import File Name: %s\n&quot;</span>, dwName);</span><br><span class="line"><span class="keyword">if</span> (dwOriginalFirstThunk == <span class="number">0x00000000</span>)</span><br><span class="line">&#123;</span><br><span class="line">dwOriginalFirstThunk = dwFirstThunk;</span><br><span class="line">&#125;</span><br><span class="line">DWORD* pdwTrunkData = (DWORD*)dwOriginalFirstThunk;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (pdwTrunkData[n] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">DWORD TrunkData = pdwTrunkData[n];</span><br><span class="line"><span class="keyword">if</span> (TrunkData &lt; IMAGE_ORDINAL_FLAG32)<span class="comment">//名字导入</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_IMPORT_BY_NAME pInportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)ImageBase + RVAOffset(pNtH, TrunkData));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ImportByName: %s\n&quot;</span>, pInportByName-&gt;Name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD FunNumber = (DWORD)(TrunkData - IMAGE_ORDINAL_FLAG32);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ImportByNumber: %-4d \n&quot;</span>, FunNumber);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">0</span> &amp;&amp; x % <span class="number">3</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">n++;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">cont = cont + <span class="number">40</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageBase)</span><br><span class="line">&#123;</span><br><span class="line">UnmapViewOfFile(ImageBase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hMapping)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hMapping);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图</p><p><img src="/../image/666.png" class="lazyload" data-srcset="/../image/666.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="666"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下图是PE文件格式示意图&lt;br&gt;&lt;img src=&quot;/2024/05/10/[逆向]PE文件格式解析/image&quot; class=&quot;lazyload&quot; data-srcset=&quot;/2024/05/10/[逆向]PE文件格式解析/image&quot; srcset=&quot;data:imag</summary>
      
    
    
    
    <category term="PE" scheme="https://5m10v3.github.io/categories/PE/"/>
    
    
    <category term="ctf学习" scheme="https://5m10v3.github.io/tags/ctf%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>日记(22)</title>
    <link href="https://5m10v3.github.io/2024/05/09/%E6%97%A5%E8%AE%B0(22)/"/>
    <id>https://5m10v3.github.io/2024/05/09/%E6%97%A5%E8%AE%B0(22)/</id>
    <published>2024-05-08T16:00:00.000Z</published>
    <updated>2024-05-12T13:04:20.519Z</updated>
    
    <content type="html"><![CDATA[<p>近期主要在弄ISCC的题目,大约弄了一周时间，从里面的安卓题学到了东西<br>接下来还是想先看完pe型结构和pe型病毒的制作，然后去看LLVM混淆，反调试</p><p>近期小目标：</p><ul><li><del>编写一个pe解析器(1天)</del></li><li>编写一个感染exe的pe型病毒(1天)（这个没有完成）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期主要在弄ISCC的题目,大约弄了一周时间，从里面的安卓题学到了东西&lt;br&gt;接下来还是想先看完pe型结构和pe型病毒的制作，然后去看LLVM混淆，反调试&lt;/p&gt;
&lt;p&gt;近期小目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;编写一个pe解析器(1天)&lt;/del&gt;&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="日记" scheme="https://5m10v3.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>日记(21)</title>
    <link href="https://5m10v3.github.io/2024/04/25/%E6%97%A5%E8%AE%B0(21)/"/>
    <id>https://5m10v3.github.io/2024/04/25/%E6%97%A5%E8%AE%B0(21)/</id>
    <published>2024-04-24T16:00:00.000Z</published>
    <updated>2024-04-26T11:38:49.370Z</updated>
    
    <content type="html"><![CDATA[<p>学习这个pe型病毒，主要目的还是再过一遍PE结构，以及一些win32API的学习</p><p>目前只是了解了这个病毒的原理，还没有具体去写</p><p>学习：</p><ul><li>Win32API的学习</li><li>PE型结构</li></ul><p>但是近期主要还是集中在学习反调试，LLVM混淆</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习这个pe型病毒，主要目的还是再过一遍PE结构，以及一些win32API的学习&lt;/p&gt;
&lt;p&gt;目前只是了解了这个病毒的原理，还没有具体去写&lt;/p&gt;
&lt;p&gt;学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Win32API的学习&lt;/li&gt;
&lt;li&gt;PE型结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但</summary>
      
    
    
    
    <category term="日记" scheme="https://5m10v3.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>PE病毒初探-注入exe</title>
    <link href="https://5m10v3.github.io/2024/04/24/PE%E7%97%85%E6%AF%92%E5%88%9D%E6%8E%A2-%E6%B3%A8%E5%85%A5exe/"/>
    <id>https://5m10v3.github.io/2024/04/24/PE%E7%97%85%E6%AF%92%E5%88%9D%E6%8E%A2-%E6%B3%A8%E5%85%A5exe/</id>
    <published>2024-04-23T16:00:00.000Z</published>
    <updated>2024-04-26T11:34:44.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、实验原理："><a href="#一、实验原理：" class="headerlink" title="一、实验原理："></a>一、实验原理：</h1><p>Win32的可执行文件，如*.exe、*.dll、*.ocx等，都是PE格式文件。感染PE格式文件的win32病毒，简称PE病毒。PE病毒同时也是所有病毒中数量极多、破坏性极大、技巧性最强的一类病毒。为了更好地发展反病毒技术，了解病毒的原理是极为必要的。一个PE病毒基本上需要具有重定位、截获API函数地址、搜索感染目标文件、内存文件映射、实施感染等几个功能，这也是病毒必须解决的几个基本问题。</p><p>PE病毒感染文件的基本步骤如下： </p><p>(1) 判断目标文件开始的两个字节是否为“MZ”。 </p><p>(2) 判断PE文件标记“PE”。 </p><p>(3) 判断感染标记，如果已被感染过则跳出继续执行HOST程序，否则继续。 </p><p>(4) 获得Directory(数据目录)的个数，(每个数据目录信息占8个字节)。 </p><p>(5) 得到节表起始位置。(Directory的偏移地址+数据目录占用的字节数&#x3D;节表起始位置)。 </p><p>(6) 遍历所有的节表，找到第一个具有可以容纳所有病毒代码空闲空间的节。 每个节的空闲空间的计算方法： 第i个节的空闲空间&#x3D;第i+1个节的虚拟地址-第i个节的虚拟地址-第i个节的Misc.VirtualSize </p><p>(7) 开始写入目标代码：</p><ol><li>计算目标代码的文件偏移位置，以后目标代码将从该位置写入PE文件。其计算方法为：目标节表的Misc.VirtualSize+目标节表的PointerToRawData</li><li>修改目标的节的节属性为0xE00000E0，是目标节变成可读、可写、可执行。</li><li>写入目标代码的数据段</li><li>写入目标代码的执行主体</li><li>修改AddressOfEntryPoint(即程序入口点指向病毒入口位置)，同时保存旧的AddressOfEntryPoint，以便返回HOST继续执行。</li><li>更新SizeOfImage(内存中整个PE映像尺寸&#x3D;原SizeOfImage+病毒节经过内存节对齐后的大小)。SizeOfCode 代码的大小，即是原SizeOfCode+病毒代码经内存对齐后的大小。</li><li>写入感染标记，在感染标记后面写入旧的AddressOfEntryPoint利于解毒。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、实验原理：&quot;&gt;&lt;a href=&quot;#一、实验原理：&quot; class=&quot;headerlink&quot; title=&quot;一、实验原理：&quot;&gt;&lt;/a&gt;一、实验原理：&lt;/h1&gt;&lt;p&gt;Win32的可执行文件，如*.exe、*.dll、*.ocx等，都是PE格式文件。感染PE格式文件的</summary>
      
    
    
    
    <category term="PE型" scheme="https://5m10v3.github.io/categories/PE%E5%9E%8B/"/>
    
    
    <category term="计算机病毒" scheme="https://5m10v3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>C++学习(三)-模板与容器</title>
    <link href="https://5m10v3.github.io/2024/04/23/C++%E5%AD%A6%E4%B9%A0(%E4%B8%89)-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%AE%B9%E5%99%A8/"/>
    <id>https://5m10v3.github.io/2024/04/23/C++%E5%AD%A6%E4%B9%A0(%E4%B8%89)-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%AE%B9%E5%99%A8/</id>
    <published>2024-04-22T16:00:00.000Z</published>
    <updated>2024-04-24T15:33:09.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h4 id="函数模板的概念"><a href="#函数模板的概念" class="headerlink" title="函数模板的概念"></a>函数模板的概念</h4><p> 函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。</p><p>关于函数模板的原理，这里偷一个图</p><p><img src="/../image/653.png" class="lazyload" data-srcset="/../image/653.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="653"></p><p>编译器编译阶段，对于函数模板的使用，<strong>编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用，彼此的地址也是不同的</strong>。比如，当用int类型使用函数模板时，编译器通过对实参类型的推演，将T确定为int类型，然后产生一份专门处理int类型的代码，对于double类型也是如此。</p><blockquote><p>&#x3D;&#x3D;小贴士：&#x3D;&#x3D;</p><blockquote><p><em>C语言为什么不支持模板，因为它不支持泛型编程(例如C++中的模板)，C语言中的宏，void *指针 ，_Generic关键字有类似的作用，但相比模板，就是小巫见大巫了。</em>*</p></blockquote></blockquote><p><strong>一、隐式实例化：让编译器根据实参推演模板参数的实际类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>, a2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">double</span> d1 = <span class="number">10.1</span>, d2 = <span class="number">20.2</span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">Add</span>(a1, a2)&lt;&lt;endl;<span class="comment">//编译器根据实参a1和a2推演出模板参数为int类型</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>(d1, d2)&lt;&lt; endl;<span class="comment">//编译器根据实参d1和d2推演出模板参数为double类型</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>(a1,d2) &lt;&lt; endl;<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编译期间，编译器根据实参推演模板参数的实际类型时，根据实参a1将T推演为int，根据实参d2将T推演为double，但是模板参数列表中只有一个T，编译器无法确定此处应该将T确定为int还是double。</p></blockquote><p>针对需要实例化的参数类型不同的问题，我们有两种处理方式：</p><ul><li>1.用户自己来强制转化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码cout &lt;&lt; <span class="built_in">Add</span>(a1,(<span class="type">int</span>)d2) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>((<span class="type">double</span>)a1, d2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>2.使用显式实例化</li></ul><p><strong>二、显示实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码cout &lt;&lt;Add &lt;<span class="type">int</span>&gt;(a1,d2) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">double</span>&gt;(a1, d2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="函数模板的匹配原则"><a href="#函数模板的匹配原则" class="headerlink" title="函数模板的匹配原则"></a>函数模板的匹配原则</h4><p>一个非模板函数可以和一个同名的函数模板同时存在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="comment">// 专门处理int的加法函数(非函数模板类型)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通用加法函数(函数模板类型)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 与非函数模板类型完全匹配，不需要函数模板实例化</span></span><br><span class="line"><span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 因为使用了显式实例化，所以只能使用函数模板实例化</span></span><br><span class="line"><span class="built_in">Add</span>(<span class="number">1.1</span>, <span class="number">2.3</span>);<span class="comment">//选择函数模板类型</span></span><br><span class="line"><span class="comment">//两者都可以使用，因为非函数模板类型属于普通函数，普通函数可以隐式地进行自动类型转换</span></span><br><span class="line"><span class="comment">//但是如果使用非函数模板类型，需要类型转换匹配，所以它会优先选择实例化模板生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板的定义格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,…,<span class="keyword">class</span> <span class="title class_">Tn</span>&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//类内成员声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//普通类：类名就是类型;</span></span><br><span class="line"><span class="comment">//类模板: 类名不是类型，类型是Stack&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Stack</span>(<span class="type">int</span> capacity=<span class="number">4</span>)</span><br><span class="line">:_a(<span class="keyword">new</span> T[acpacity])</span><br><span class="line">,_top(<span class="number">0</span>)</span><br><span class="line">,_capacity(capacity)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Stack</span>()</span><br><span class="line">&#123;</span><br><span class="line">dalete[] _a;</span><br><span class="line">_a = <span class="literal">nullptr</span>;</span><br><span class="line">_top = _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类里面声明，类外面定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _a;</span><br><span class="line"><span class="type">int</span> _top;</span><br><span class="line"><span class="type">int</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">cpp复制代码<span class="comment">//类外面定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//类模板中的成员函数若是放在类外定义时，需要加模板参数列表</span></span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：<strong>模板不支持把声明写到.h ，定义写到.cpp这种声明和定义分开的方式，会报链接错误</strong></p><h4 id="类模板的实例化"><a href="#类模板的实例化" class="headerlink" title="类模板的实例化"></a>类模板的实例化</h4><p>类模板实例化需要在类模板名字后面根&lt;&gt;，然后将实例化的类型放在&lt;&gt;中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//类模板的使用都是显示实例化</span></span><br><span class="line">Stack&lt;TreeNode*&gt; st1;<span class="comment">//TreeNode*</span></span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; st2;<span class="comment">//int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><p>模板参数可分为<strong>类型形参</strong>和<strong>非类型形参</strong>。</p><blockquote><ul><li>类型形参： 出现在模板参数列表中，跟在class或typename关键字之后的参数类型名称。</li><li>非类型形参： 用一个常量作为类（函数）模板的一个参数，在类（函数）模板中可将该参数当成常量来使用。</li></ul></blockquote><p>我们来举个例子： 定义一个静态的栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T _a[N];</span><br><span class="line"><span class="type">size_t</span> top;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; sk1;<span class="comment">//10</span></span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; sk2;<span class="comment">//假设我们同时还想要一个大小为1000的栈（sk2）,因为N的限制，我们只能定义多个栈</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用<strong>非类型模板参数</strong>来解决这个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> ,<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T _a[N];</span><br><span class="line"><span class="type">size_t</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack&lt;<span class="type">int</span>,<span class="number">10</span>&gt; sk1;<span class="comment">//10</span></span><br><span class="line">Stack&lt;<span class="type">int</span>,<span class="number">1000</span>&gt; sk2;<span class="comment">//1000</span></span><br><span class="line"><span class="comment">//这样通过控制Stack&lt;int,m&gt; 中的m（m必须是常量）值可以实现多个大小不同的栈</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&#x2F;&#x2F;模板参数都可以设置缺省值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N=<span class="number">10</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T _a[N];</span><br><span class="line"><span class="type">size_t</span> top;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; sk1;<span class="comment">//10(使用缺省值：默认给10)</span></span><br><span class="line">Stack&lt;<span class="type">int</span>, <span class="number">1000</span>&gt; sk2;<span class="comment">//1000（如果这里给了，不使用缺省值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：</p><blockquote><p>1.非类型模板参数只允许使用整型家族；浮点数、类对象以及字符串是不允许作为非类型模板参数的。 2.非类型的模板参数在编译期就需要确认结果，因为编译器在编译阶段就需要根据传入的非类型模板参数生成对应的类或函数。</p></blockquote><h3 id="模板的特化"><a href="#模板的特化" class="headerlink" title="模板的特化"></a>模板的特化</h3><p>模板特化：在原模板类的基础上，针对特殊类型所进行的特殊化的实现。分为函数模板特化 和类模板特化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>对于该函数模板，当实参为两个char指针时，比较的是指针的大小，而不是指针指向内容的大小，此时就需要为该函数模板定义一个特化版本，即特殊处理的版本。</p><blockquote><p>函数模板的特化步骤：</p><ul><li>首先必须要有一个基础的函数模板。</li><li>关键字template后面接一对空的尖括号&lt;&gt;。</li><li>函数名后跟一对尖括号，尖括号中指定需要特化的类型。</li><li>函数形参表必须要和模板函数的基础参数类型完全相同，否则不同的编译器可能会报一些奇怪的错误。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="comment">//为实参类型 const char * 提供特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">int</span> <span class="built_in">compare</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> &amp;v1, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>解读：</p><ol><li><code>template &lt;&gt;</code> &#x2F;&#x2F;空模板形参表</li><li><code>compare&lt;const char *&gt;</code> &#x2F;&#x2F;模板名字后指定特化时的模板形参即const char * 类型，就是说在以实参类型const char * 调用函数时，将产生该模板的特化版本，而不是泛型版本。</li><li><code>(const char * const &amp;v1, const char * const &amp;v2)</code>&#x2F;&#x2F;可以理解为: const  char * const &amp;v1, 去掉const修饰符，实际类型是：char *&amp;v1，也就是v1是一个引用，一个指向char型指针的引用，即指针的引用，加上const修饰符，v1就是一个指向const char 型指针的 const引用，对v1的操作就是对指针本身的操作，</li></ol><h4 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h4><blockquote><p>类模板的特化分为全特化和偏特化。</p></blockquote><p><strong>全特化： 对类模板参数列表的类型全部都确定（明确指定）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="comment">//基础</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Date&lt;T1, T2&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 _d1;</span><br><span class="line">T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Date&lt;int, double&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _d1;</span><br><span class="line"><span class="type">double</span> _d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>偏特化： 堆类模板的参数列表中部分参数进行确定化分为部分特化和参数进一步限制</strong></p><p>部分特化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="comment">// 部分</span></span><br><span class="line"><span class="comment">// 偏特化/半特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &lt;T1, <span class="type">char</span>&gt;<span class="comment">//只要第二个类型是char就匹配这个</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1, char&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参数进一步限制 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码<span class="comment">// 对模板参数更进一步的条件限制</span></span><br><span class="line"><span class="comment">// 偏特化/半特化：不一定指的是特化部分参数，而是对模板参数类型的进一步限制</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &lt;T1*, T2*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1*, T2*&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &lt; T1&amp;, T2&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1&amp;, T2&amp;&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &lt; T1&amp;, T2* &gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1&amp;, T2*&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="一、什么是STL"><a href="#一、什么是STL" class="headerlink" title="一、什么是STL?"></a>一、什么是STL?</h3><p>1、STL（Standard Template Library），即标准模板库，是一个高效的C++程序库，包含了诸多常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。</p><p>2、从逻辑层次来看，在STL中体现了<strong>泛型</strong>化程序设计的思想（generic programming）。在这种思想里，大部分基本算法被抽象，被泛化，独立于与之对应的数据结构，用于以相同或相近的方式处理各种不同情形。</p><p>3、从实现层次看，整个STL是以一种类型参数化（type parameterized）的方式实现的，基于<strong>模板</strong>（template）。</p><p>STL有六大组件，但主要包含容器、迭代器和算法三个部分。</p><ul><li><strong>容器</strong>（Containers）：用来管理某类对象的集合。每一种容器都有其优点和缺点，所以为了应付程序中的不同需求，STL 准备了七种基本容器类型。</li><li><strong>迭代器</strong>（Iterators）：用来在一个对象集合的元素上进行遍历动作。这个对象集合或许是个容器，或许是容器的一部分。每一种容器都提供了自己的迭代器，而这些迭代器了解该种容器的内部结构。</li><li><strong>算法</strong>（Algorithms）：用来处理对象集合中的元素，比如 Sort，Search，Copy，Erase 那些元素。通过迭代器的协助，我们只需撰写一次算法，就可以将它应用于任意容器之上，这是因为所有容器的迭代器都提供一致的接口。</li></ul><p>STL 的基本观念就是将数据和操作分离。数据由容器进行管理，操作则由算法进行，而迭代器在两者之间充当粘合剂，使任何算法都可以和任何容器交互运作。</p><h3 id="二、容器（Containers）"><a href="#二、容器（Containers）" class="headerlink" title="二、容器（Containers）"></a>二、容器（Containers）</h3><p>容器用来管理某类对象。为了应付程序中的不同需求，STL 准备了两类共七种基本容器类型：</p><ul><li>序列式容器（Sequence containers），此为可序群集，其中每个元素均有固定位置—取决于插入时机和地点，和元素值无关。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器：向量（vector）、双端队列（deque）、列表（list），此外你也可以把 string 和 array 当做一种序列式容器。</li><li>关联式容器（Associative containers），此为已序群集，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的位置取决于元素值，和插入次序无关。STL提供了四个关联式容器：集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）。</li></ul><p>示意图如下图所示：</p><p><img src="/../image/654.png" class="lazyload" data-srcset="/../image/654.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="654"></p><h4 id="2-1-vector"><a href="#2-1-vector" class="headerlink" title="2.1 vector"></a>2.1 vector</h4><p>vector（向量）: 是一种序列式容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而 vector 正好弥补了这个缺陷，当内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。</p><p><strong>特点</strong></p><ul><li>拥有一段连续的内存空间，因此它能非常好的支持随机访问，即 [] 操作符和 .at()，随机访问快。（优点）</li><li>当向其头部或中间插入或删除元素时，为了保持原本的相对次序，插入或删除点之后的所有元素都必须移动，所以插入或删除的效率比较低。（缺点）</li><li>在后面插入删除元素最快，此时一般不需要移动内存。（优点）</li><li>总结：相当于可拓展的数组（动态数组），随机访问快，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。</li></ul><p><strong>适用场景</strong></p><p>适用于对象简单，变化较小，并且频繁随机访问的场景。</p><p><strong>例子</strong></p><p>以下例子针对整型定义了一个 vector，插入 6 个元素，然后打印所有元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecTemp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">vecTemp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;vecTemp.<span class="built_in">size</span>(); i++)</span><br><span class="line">cout &lt;&lt; vecTemp[i] &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 输出：0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-deque"><a href="#2-2-deque" class="headerlink" title="2.2 deque"></a>2.2 deque</h4><p>deque（double-ended queue）是双向开口的连续内存空间（动态将多个连续空间通过指针数组接合在一起），随时可以增加一段新的空间。deque 的最大任务就是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口。</p><p><strong>特点</strong></p><ul><li>一旦要在 deque 的头部和尾部增加新空间，便配置一段定量连续空间，串在整个 deque 的头部或尾部，因此不论在头部或尾部插入元素都十分迅速。 (优点）</li><li>在中间部分安插元素则比较费时，因为必须移动其它元素。（缺点）</li><li>deque 是 list 和 vector 的折中方案。兼有 list 的优点，也有 vector 随机访问效率高的优点。</li><li>总结：支持随机访问，但效率没有 vector 高，在头部和尾部插入或删除效率高，但在中间插入或删除效率低。</li></ul><p><strong>适用场景</strong></p><p>适用于既要频繁随机访问，又要关心两端数据的插入与删除的场景。</p><p><strong>例子</strong></p><p>以下例子声明了一个浮点类型的 deque，并在容器尾部插入 6 个元素，最后打印出所有元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">float</span>&gt; dequeTemp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">dequeTemp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;dequeTemp.<span class="built_in">size</span>(); i++)</span><br><span class="line">cout &lt;&lt; dequeTemp[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-list"><a href="#2-3-list" class="headerlink" title="2.3 list"></a>2.3 list</h4><p>List 由双向链表（doubly linked list）实现而成，元素存放在堆中，每个元素都是放在一块内存中。没有空间预留习惯，所以每分配一个元素都会从内存中分配，每删除一个元素都会释放它占用的内存。</p><p><strong>特点</strong></p><ul><li>内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。（缺点）</li><li>由于链表的特点，在任意位置的插入和删除效率都较高。（优点）</li><li>只支持首尾两个元素的直接存取，想获取其他元素（访问时间一样），则需要遍历链表。（缺点）</li><li>总结：不支持随机访问，在任意位置的插入和删除效率都较高。</li></ul><p><strong>适用场景</strong></p><p>适用于经常进行插入和删除操作并且不经常随机访问的场景。</p><p><strong>例子</strong></p><p>以下例子产生一个空 list，准备放置字符，然后将 ‘a’ 至 ‘z’ 的所有字符插入其中，利用循环每次打印并移除集合的第一个元素，从而打印出所有元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">char</span>&gt; listTemp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c)</span><br><span class="line">listTemp.<span class="built_in">push_back</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!listTemp.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;listTemp.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">listTemp.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数<code>empty()</code>的返回值告诉我们容器中是否还有元素，只要这个函数返回 false，循环就继续进行。循环之内，成员函数<code>front()</code>会返回第一个元素，<code>pop_front()</code>函数会删除第一个元素。</p><p>注意：list&lt;指针&gt; 完全是性能最低的做法，还不如直接使用 list&lt;对象&gt; 或使用 vector&lt;指针&gt; 好，因为指针没有构造与析构，也不占用很大内存。</p><h4 id="2-4-set"><a href="#2-4-set" class="headerlink" title="2.4 set"></a>2.4 set</h4><p>set（集合）顾名思义，就是数学上的集合——每个元素最多只出现一次，并且 set 中的元素已经从小到大排好序。</p><p><strong>特点</strong></p><ul><li>使用红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复。</li><li>每次插入值的时候，都需要调整红黑树，效率有一定影响。（缺点）</li><li>map 和 set 的插入或删除效率比用其他序列容器高，因为对于关联容器来说，不需要做内存拷贝和内存移动。（优点）</li><li>总结：由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，且插入和删除效率比用其他序列容器高。</li></ul><p><strong>适用场景</strong></p><p>适用于经常查找一个元素是否在某集合中且需要排序的场景。</p><p><strong>例子</strong></p><p>下面的例子演示 set（集合）的两个特点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; setTemp;</span><br><span class="line"></span><br><span class="line">setTemp.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = setTemp.<span class="built_in">begin</span>(); it != setTemp.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：1 2 3。一共插入了 4 个数，但是集合中只有 3 个数并且是有序的，可见之前说过的 set 集合的两个特点，有序和不重复。</p><p>当 set 集合中的元素为结构体时，该结构体必须实现运算符 ‘&lt;’ 的重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> People p) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> age &lt; p.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;People&gt; setTemp;</span><br><span class="line"></span><br><span class="line">setTemp.<span class="built_in">insert</span>(&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">14</span>&#125;);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(&#123; <span class="string">&quot;李四&quot;</span>, <span class="number">16</span> &#125;);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(&#123; <span class="string">&quot;隔壁老王&quot;</span>, <span class="number">10</span> &#125;);</span><br><span class="line"></span><br><span class="line">set&lt;People&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = setTemp.<span class="built_in">begin</span>(); it != setTemp.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d\n&quot;</span>, (*it).name.<span class="built_in">c_str</span>(), (*it).age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">姓名：王二麻子 年龄：10</span></span><br><span class="line"><span class="comment">姓名：张三 年龄：14</span></span><br><span class="line"><span class="comment">姓名：李四 年龄：16 </span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure><p>可以看到结果是按照年龄由小到大的顺序排列。另外 string 要使用<code>c_str()</code>转换一下，否则打印出的是乱码。</p><p>另外 Multiset 和 set 相同，只不过它允许重复元素，也就是说 multiset 可包括多个数值相同的元素。这里不再做过多介绍。</p><h4 id="2-5-map"><a href="#2-5-map" class="headerlink" title="2.5 map"></a>2.5 map</h4><p>map 由红黑树实现，其元素都是 “键值&#x2F;实值” 所形成的一个对组（key&#x2F;value pairs)。</p><p>map 主要用于资料一对一映射的情况，map 内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在 map 内部所有的数据都是有序的。比如一个班级中，每个学生的学号跟他的姓名就存在着一对一映射的关系。</p><p><strong>特点</strong></p><ul><li>每个元素都有一个键，且只能出现一次，不允许重复。</li><li>根据 key 值快速查找记录，查找的复杂度基本是 O(logN)，如果有 1000 个记录，二分查找最多查找 10次(1024)。（优点）</li><li>每次插入值的时候，都需要调整红黑树，效率有一定影响。（缺点）</li><li>增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。（优点）</li><li>对于迭代器来说，可以修改实值，而不能修改 key。</li><li>总结：元素为键值对，key 和 value 可以是任意你需要的类型，每个元素都有一个键，且只能出现一次，不允许重复，根据 key 快速查找记录。</li></ul><p><strong>适用场景</strong></p><p>适用于需要存储一个数据字典，并要求方便地根据key找value的场景。</p><p><strong>例子</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapTemp;</span><br><span class="line"></span><br><span class="line">mapTemp.<span class="built_in">insert</span>(&#123; <span class="number">5</span>,<span class="string">&quot;张三&quot;</span> &#125;);</span><br><span class="line">mapTemp.<span class="built_in">insert</span>(&#123; <span class="number">3</span>, <span class="string">&quot;李四&quot;</span>&#125;);</span><br><span class="line">mapTemp.<span class="built_in">insert</span>(&#123; <span class="number">4</span>, <span class="string">&quot;隔壁老王&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = mapTemp.<span class="built_in">begin</span>(); it != mapTemp.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学号：%d 姓名：%s\n&quot;</span>, (*it).first, (*it).second.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">学号：3 姓名：李四</span></span><br><span class="line"><span class="comment">学号：4 姓名：隔壁老王</span></span><br><span class="line"><span class="comment">学号：5 姓名：张三</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>multimap 和 map 相同，但允许重复元素，也就是说 multimap 可包含多个键值（key）相同的元素。这里不再做过多介绍。</p><h4 id="2-6-容器配接器"><a href="#2-6-容器配接器" class="headerlink" title="2.6 容器配接器"></a>2.6 容器配接器</h4><p>除了以上七个基本容器类别，为满足特殊需求，STL还提供了一些特别的（并且预先定义好的）容器配接器，根据基本容器类别实现而成。包括：</p><p><strong>1、stack</strong></p><p>名字说明了一切，stack 容器对元素采取 LIFO（后进先出）的管理策略。</p><p><strong>2、queue</strong></p><p>queue 容器对元素采取 FIFO（先进先出）的管理策略。也就是说，它是个普通的缓冲区（buffer）。</p><p><strong>3、priority_queue</strong></p><p>priority_queue 容器中的元素可以拥有不同的优先权。所谓优先权，乃是基于程序员提供的排序准则（缺省使用 operators）而定义。Priority queue 的效果相当于这样一个 buffer：“下一元素永远是queue中优先级最高的元素”。如果同时有多个元素具备最髙优先权，则其次序无明确定义。</p><p><a href="https://www.cnblogs.com/linuxAndMcu/p/10254542.html#_labelTop">回到顶部</a></p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p><strong>各容器的特点总结</strong></p><ul><li>vector 支持随机访问，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。</li><li>支持随机访问，但效率没有 vector 高，在头部和尾部插入或删除效率高，但在中间插入或删除效率低。</li><li>list 不支持随机访问，在任意位置的插入和删除效率都较高。</li><li>set 由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，且插入和删除效率比用其他序列容器高。</li><li>map 的元素为键值对，key 和 value 可以是任意你需要的类型，每个元素都有一个键，且只能出现一次，不允许重复，根据 key 快速查找记录。</li></ul><p>在实际使用过程中，到底选择这几种容器中的哪一个，应该根据遵循以下原则：</p><p>1、如果需要高效的随机访问，不在乎插入和删除的效率，使用 vector。 2、如果需要随机访问，并且关心两端数据的插入和删除效率，使用 deque。 3、如果需要大量的插入和删除元素，不关心随机访问的效率，使用 list。 4、如果经常查找一个元素是否在某集合中且需要排序，唯一存在的情况使用 set，不唯一存在的情况使用 multiset。 5、如果打算存储数据字典，并且要求方便地根据 key 找到 value，一对一的情况使用 map，一对多的情况使用 multimap。 </p><p><strong>各容器的时间复杂度分析</strong></p><ul><li>vector 在头部和中间位置插入和删除的时间复杂度为 O(N)，在尾部插入和删除的时间复杂度为 O(1)，随机访问的时间复杂度为 O(1)，查找的时间复杂度为 O(N)；</li><li>deque 在中间位置插入和删除的时间复杂度为 O(N)，在头部和尾部插入和删除的时间复杂度为 O(1)，随机访问的时间复杂度为 O(1)，查找的时间复杂度为 O(N)；</li><li>list 在任意位置插入和删除的时间复杂度都为 O(1)，查找的时间复杂度为 O(N)；</li><li>set 和 map 都是通过红黑树实现，因此插入、删除和查找操作的时间复杂度都是 O(log N)。</li></ul><p><strong>各容器的共性</strong></p><p>各容器一般来说都有下列函数：默认构造函数、复制构造函数、析构函数、empty()、max_size()、size()、operator&#x3D;、operator&lt;、operator&lt;&#x3D;、operator&gt;、operator&gt;&#x3D;、operator&#x3D;&#x3D;、operator!&#x3D;、swap()。</p><p>顺序容器和关联容器都共有下列函数：</p><ul><li><code>begin()</code> ：返回容器第一个元素的迭代器指针；</li><li><code>end()</code>：返回容器最后一个元素后面一位的迭代器指针；</li><li><code>rbegin()</code>：返回一个逆向迭代器指针，指向容器最后一个元素；</li><li><code>rend()</code>：返回一个逆向迭代器指针，指向容器首个元素前面一位；</li><li><code>clear()</code>：删除容器中的所有的元素；</li><li><code>erase(it)</code>：删除迭代器指针it处元素。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h2&gt;&lt;h4 id=&quot;函数模板的概念&quot;&gt;&lt;a href=&quot;#函数模板的概念&quot; class=&quot;headerlink&quot; title=&quot;函数模板的概念&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="C++" scheme="https://5m10v3.github.io/categories/C/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++学习(二)-继承与多态</title>
    <link href="https://5m10v3.github.io/2024/04/22/C++%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <id>https://5m10v3.github.io/2024/04/22/C++%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</id>
    <published>2024-04-21T16:00:00.000Z</published>
    <updated>2024-04-24T11:00:36.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><img src="/../image/649.png" class="lazyload" data-srcset="/../image/649.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="649"></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h3 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h3><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通实现界面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...(公共头部)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java、Python、C++...（公共列表信息）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...(公共头部)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java、Python、C++...（公共列表信息）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...(公共头部)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java、Python、C++...（公共列表信息）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++ 学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java 下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Java ja;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python 下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Python py;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++ 下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    CPP Cpp;</span><br><span class="line">    Cpp.<span class="built_in">header</span>();</span><br><span class="line">    Cpp.<span class="built_in">footer</span>();</span><br><span class="line">    Cpp.<span class="built_in">left</span>();</span><br><span class="line">    Cpp.<span class="built_in">content</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承实现页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共页面类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...(公共头部)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java、Python、C++...（公共列表信息）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承的好处：减少重复代码</span></span><br><span class="line"><span class="comment">// 语法：class 子类 : 继承方式 父类</span></span><br><span class="line"><span class="comment">// 子类  也称为  派生类</span></span><br><span class="line"><span class="comment">// 父类  也称为  基类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java 学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Python 页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python 学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++ 学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java 下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Java ja;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python 下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Python py;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++ 下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    CPP Cpp;</span><br><span class="line">    Cpp.<span class="built_in">header</span>();</span><br><span class="line">    Cpp.<span class="built_in">footer</span>();</span><br><span class="line">    Cpp.<span class="built_in">left</span>();</span><br><span class="line">    Cpp.<span class="built_in">content</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：可以减少重复的代码</p><p>class A : public B;</p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承的语法：<code>class 子类 : 继承方式 父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="/../image/650.png" class="lazyload" data-srcset="/../image/650.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="650"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">10</span>; <span class="comment">// 父类中的公共权限成员 到子类中依然是公共权限成员</span></span><br><span class="line">        m_B = <span class="number">20</span>; <span class="comment">// 父类中的保护权限成员 到子类中依然是保护权限成员</span></span><br><span class="line">        <span class="comment">// m_C = 10; // 父类中的私有权限成员  子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s1;</span><br><span class="line">    s1.m_A = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// s1.m_B = 100; // 到了 Son1 中 m_B 是保护权限 类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">100</span>; <span class="comment">// 父类中公共成员，到子类中变成保护成员</span></span><br><span class="line">        m_B = <span class="number">100</span>; <span class="comment">// 父类中保护成员，到子类中变成保护成员</span></span><br><span class="line">        <span class="comment">// m_C = 100; // 父类中私有成员 子类访问不到  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son2 s1;</span><br><span class="line">    <span class="comment">// s1.m_A = 1000; // 在 Son2 中 m_A变为保护权限，因此类外访问不到</span></span><br><span class="line">    <span class="comment">// s1.m_B = 1000; // 在 Son2 中 m_B变为保护权限，因此类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> : <span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">100</span>; <span class="comment">// 父类中公共成员，到子类中变成私有成员</span></span><br><span class="line">        m_B = <span class="number">100</span>; <span class="comment">// 父类中保护成员，到子类中变成私有成员</span></span><br><span class="line">        <span class="comment">// m_C = 100; // 父类中私有成员，子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son3 s1;</span><br><span class="line">    <span class="comment">// s1.m_A = 1000; // 到 Sno3 中 变成私有成员 类外访问不到</span></span><br><span class="line">    <span class="comment">// s1.m_B = 1000; // 到 Sno3 中 变成私有成员 类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> : <span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// m_A = 1000; // 到了 Son3 中 m_A 变为了私有，即使是儿子，也是访问不到的</span></span><br><span class="line">        <span class="comment">// m_B = 1000; // 到了 Son3 中 m_A 变为了私有，即使是儿子，也是访问不到的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承中的对象模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用开发人员命令提示工具查看对象模型</span></span><br><span class="line"><span class="comment">// 查看命令</span></span><br><span class="line"><span class="comment">// cl /d1 reportSingleClassLayout类名 &quot;文件名.cpp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 16</span></span><br><span class="line">    <span class="comment">// 父类中所有非静态成员属性都会被子类继承下去</span></span><br><span class="line">    <span class="comment">// 父类中私有成员属性 是被编译器隐藏了，因此访问不到，但是确实被继承下去了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p><h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承中的构造和析构的顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Base b;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承中的构造和析构顺序如下：</span></span><br><span class="line">    <span class="comment">// 先构造父类，再构造子类，析构的顺序与构造的顺序相反</span></span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p><h3 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h3><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承中同名成员处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - func() 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - func(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son - func() 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名成员变量处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 如果通过子类对象 访问到父类中同名成员，需要加作用域</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名成员函数处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">func</span>(); <span class="comment">// 直接调用 调用的是子类中的同名成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何调用父类中的同名成员函数？</span></span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子类中出现和父类同名的成员函数，子类的同名函数会隐藏掉父类中所有的同名函数</span></span><br><span class="line">    <span class="comment">// 如果想访问到父类中被隐藏的同名成员函数，需要加作用域</span></span><br><span class="line">    s.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h3 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h3><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承中的同名静态成员处理方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特点</span></span><br><span class="line">    <span class="comment">// 1、编译期间分配内存</span></span><br><span class="line">    <span class="comment">// 2、所有对象共享同一份数据</span></span><br><span class="line">    <span class="comment">// 3、类内声明，类外初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func() 的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func(int a) 的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son - static void func() 的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名静态成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、通过对象访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son 下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过类名访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son 下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 第一个 :: 代表通过类名方式访问  第二个 :: 表示访问父类作用域</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、通过对象访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过类名访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son::<span class="built_in">func</span>();</span><br><span class="line">    Son::Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类出现和父类同名静态成员函数，也会隐藏父类中的所用同名成员函数</span></span><br><span class="line">    <span class="comment">// 如果想访问父类中被隐藏同名成员，必须加作用域</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p><h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类  需要继承 Base1 和 Base2 </span></span><br><span class="line"><span class="comment">// 语法： class 子类 : 继承方法 父类, 继承方法 父类 ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_C = <span class="number">300</span>;</span><br><span class="line">        m_D = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 当父类中出现同名成员，需要加作用域</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base1::m_A = &quot;</span> &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base2::m_A = &quot;</span> &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p><strong>菱形继承概念：</strong></p><p> 两个派生类继承同一个基类</p><p> 又有某个类同时继承者两个派生类</p><p> 这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="/../image/651.png" class="lazyload" data-srcset="/../image/651.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="651"></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code class="undefined">羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```undefined</span><br><span class="line">   草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</span><br></pre></td></tr></table></figure></code></pre></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用虚继承 解决菱形继承问题</span></span><br><span class="line"><span class="comment">// 在继承之前 加上关键字 virtual 变成为虚继承</span></span><br><span class="line"><span class="comment">// Animal 类称为 虚基类</span></span><br><span class="line"><span class="comment">// 羊类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 骆驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 羊驼</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line"></span><br><span class="line">    st.Sheep::m_Age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  当菱形继承，两个父类拥有相同数据，需要加以作用域</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这份数据我们知道，只要一份就可以了，菱形继承导致数据有两份，资源浪费</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 重写  函数返回值类型  函数名 函数列表 完全相同</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 狗类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行说话的函数</span></span><br><span class="line"><span class="comment">// 地址早绑定  在编译阶段确定函数地址</span></span><br><span class="line"><span class="comment">// 如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段绑定，地址晚绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态多态满足条件</span></span><br><span class="line"><span class="comment">// 1、有继承关系</span></span><br><span class="line"><span class="comment">// 2、子类重写父类的虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态多态使用</span></span><br><span class="line"><span class="comment">// 父类的指针或者引用 指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(Animal* animal)</span> <span class="comment">// Animal &amp;animal = cat;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">doSpeak</span>(&amp;cat);</span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">doSpeak</span>(&amp;dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p><h3 id="动态多态——虚函数"><a href="#动态多态——虚函数" class="headerlink" title="动态多态——虚函数"></a>动态多态——虚函数</h3><p>虚函数的产生，其实是因为上面提到的，指针居然可以指向不同于指针类型的类型。这就会产生一个问题，我就想用基类指针指向的派生对象的派生函数，那咋办嘛。</p><p>于是，虚函数，就是在执行的时候，才会根据其指针指向的对象是基类还是派生类，来进行对应的重载。这也正是动态重载的定义——在执行的时候，再进行重载。</p><p>举个栗子，现有 <code>ShoppingCard</code> 与其派生类 <code>MemberCard</code>，想对一个 <code>ShoppingCard</code> 实现虚函数，具体的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 父类成员函数加 virtual</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">consume</span><span class="params">(<span class="type">float</span> money)</span></span>; <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 派生类函数名、参数、返回值完全一致</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberCard</span>: <span class="keyword">public</span> ShoppingCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">consume</span><span class="params">(<span class="type">float</span> money)</span></span>; <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对派生类的对象使用基类的引用/指针</span></span><br><span class="line">ShoppingCard * card = <span class="keyword">new</span> MemberCard;</span><br><span class="line">MemberCard.<span class="built_in">consume</span>(<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>注意虚函数有条件：他不能为以下函数之一：</p><ul><li>静态成员函数</li><li>全局函数</li><li>友元函数</li></ul><h3 id="虚函数的实现"><a href="#虚函数的实现" class="headerlink" title="虚函数的实现"></a>虚函数的实现</h3><p>该部分不难，不过仅作了解。</p><p>简单的来说，就是两句话：</p><ol><li>编译时，每个定义了虚函数的类会有其对应的 <strong>虚函数表</strong> VTABLE，存有该类中。（派生类的存在派生类里）</li><li>创建对象时，每个对象会获得指向其<strong>对应的 VTABLE</strong> 的指针。</li></ol><h3 id="虚构造函数和析构函数"><a href="#虚构造函数和析构函数" class="headerlink" title="虚构造函数和析构函数"></a>虚构造函数和析构函数</h3><p>虚构造函数是不存在的。该问题等价于 <code>先有鸡还是先有蛋</code>。（想想，为什么？）</p><p>而虚析构函数就没有这个问题，其本质和其他虚函数是一样的。</p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为抽象类</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯虚函数和抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="comment">// 只要有一个纯虚函数，这个类称为抽象类</span></span><br><span class="line"><span class="comment">// 抽象类特点：</span></span><br><span class="line"><span class="comment">// 1、无法实例化对象</span></span><br><span class="line"><span class="comment">// 2、抽象类的子类  必须要重新父类中纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Base b; // 抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">// new Base; // 抽象类无法实例化对象</span></span><br><span class="line"></span><br><span class="line">Son s; <span class="comment">// 子类必须重写父类中的纯虚函数，否则无法实例化对象</span></span><br><span class="line">Base* base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">// 记得销毁</span></span><br><span class="line"><span class="keyword">delete</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual ~类名()&#123;&#125;</span><br></pre></td></tr></table></figure><p>纯虚析构语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtual ~类名() = 0;</span><br><span class="line">类名::~类名()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚析构和纯虚析构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用虚析构可以解决 父类指针释放子类对象时不干净的问题</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal 虚析构函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯虚析构  需要声明也需要实现</span></span><br><span class="line"><span class="comment">// 有了纯虚析构之后，这个类也属于抽象类，无法实例化对象</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat 构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Name != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat 析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string* m_Name;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line"><span class="comment">// 父类指针在析构时候 不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄漏</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><p>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p></li><li><p>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">3.</span> 拥有纯虚析构函数的类也属于抽象类</span><br></pre></td></tr></table></figure><h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><p>说了那么多，那动态多态有什么用嘛，还搞得好复杂，甚至还可能出现漏洞。</p><p>于是我去知乎搜了一下：</p><blockquote><p>首先需要明确多态性的用途，是为了<strong>接口的最大程度复用</strong>，以及其定义：</p><p>多态性的定义，可以简单地概括为“<strong>一个接口，多种方法</strong>”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。多态分为静态多态和动态多态。<br>静态多态是通过重载和模板技术实现，在编译的时候确定。<br>动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。 ——<a href="https://zhuanlan.zhihu.com/p/47057750">https://zhuanlan.zhihu.com/p/47057750</a></p></blockquote><p>静态多态能实现接口的很大程度的复用，而动态多态就可以最大化复用的程度吧。</p><blockquote><p>2020.1.6 更新：在写了一个大实验以后，我发现了动态多态在实战中的用途。</p></blockquote><p>简单的来说，现在有 <code>class A</code> 为基类，其有派生类 <code>A1</code>、<code>A2</code>、<code>A3</code> 等。我们定义 <code>std::vector&lt;A*&gt;</code>，里面的指针可能指向 <code>A1</code>、<code>A2</code>、<code>A3</code>。</p><p>使用动态多态的话，可以实现：将<strong>多个不同的派生类 <code>Ai</code> 装在一个集合中</strong>，但是调用的时候却是<strong>调用 <code>Ai</code> 各自派生类的成员函数</strong>。</p><p>静态多态则做不到，在 <code>Ai</code> 转为 <code>A</code> 的一瞬间，他就失去了他的派生成员。如下程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> <span class="comment">//尝试静态多态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">A1 a1;</span><br><span class="line">vector&lt;A&gt; vA;</span><br><span class="line">vA.<span class="built_in">push_back</span>(a);</span><br><span class="line">vA.<span class="built_in">push_back</span>(a1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : vA)</span><br><span class="line">i.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> <span class="comment">//动态多态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A * a = <span class="keyword">new</span> A;</span><br><span class="line">A1 * a1 = <span class="keyword">new</span> A1;</span><br><span class="line">vector&lt;A*&gt; vA;</span><br><span class="line">vA.<span class="built_in">push_back</span>(a);</span><br><span class="line">vA.<span class="built_in">push_back</span>(a1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : vA)</span><br><span class="line">i-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test1</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/652.png" class="lazyload" data-srcset="/../image/652.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="652"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/../image/649.png&quot; class=&quot;lazyload&quot; data-srcset=&quot;/../image/6</summary>
      
    
    
    
    <category term="C++" scheme="https://5m10v3.github.io/categories/C/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++学习(一)-类与重载</title>
    <link href="https://5m10v3.github.io/2024/04/21/C++%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%B1%BB%E4%B8%8E%E9%87%8D%E8%BD%BD/"/>
    <id>https://5m10v3.github.io/2024/04/21/C++%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%B1%BB%E4%B8%8E%E9%87%8D%E8%BD%BD/</id>
    <published>2024-04-20T16:00:00.000Z</published>
    <updated>2024-04-24T10:24:02.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><h3 id="使用-new-运算符-分配内存-并-初始化"><a href="#使用-new-运算符-分配内存-并-初始化" class="headerlink" title="使用 new 运算符 分配内存 并 初始化"></a>使用 new 运算符 分配内存 并 初始化</h3><p>1.分配内存初始化标量类型（如 int 或 double），在类型名后加初始值，并用小括号括起，C++11中也支持大括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int * pi = new int (6); </span><br><span class="line">double * pd = new double (9.99); </span><br><span class="line">//C++11中, 支持以下写法</span><br><span class="line">int * pi = new int &#123;6&#125;; </span><br><span class="line">double * pd = new double &#123;9.99&#125;;</span><br></pre></td></tr></table></figure><p>2.初始化结构或数组，需要使用大括号列表初始化 ，需编译器 <strong>支持 C++11</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct where&#123;double x; double y; double z;&#125;;</span><br><span class="line">where * one = new where &#123;1.2, 2.2, 3.2&#125;;</span><br><span class="line">int * ar = new int [4] &#123;1, 2, 3, 4&#125;;</span><br></pre></td></tr></table></figure><p>3.使用 delete 释放 new分配的内存 （仅限于常规 new 分配的 堆内存）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete pi;</span><br><span class="line">delete pd;</span><br><span class="line">delete one;</span><br><span class="line">// 释放数组 记住 加[]</span><br><span class="line">delete [] ar;</span><br></pre></td></tr></table></figure><p>4.创建类对象</p><p>（1）new创建对象，pTest用来接收对象指针。new申请的对象，则只有调用到delete时才会执行析构函数，如果程序退出而没有执行delete则会造成内存泄漏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTest*  pTest = new  CTest();  delete pTest;</span><br></pre></td></tr></table></figure><p>（2）不用new，直接使用类定义申明，使用完后不需要手动释放，该类析构函数会自动执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTest  mTest;</span><br></pre></td></tr></table></figure><p>（3）使用普通方式创建的类对象，在创建之初就已经分配了内存空间。而类指针，如果未经过对象初始化，则不需要delete释放：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTest*  pTest = NULL;</span><br></pre></td></tr></table></figure><h3 id="new-失败时处理方式"><a href="#new-失败时处理方式" class="headerlink" title="new 失败时处理方式"></a>new 失败时处理方式</h3><p>1.常规分配内存，调用构造函数。分配失败时，<strong>抛出异常</strong>。定义如下：</p><blockquote><p>void* operator new(std::size_t) throw(std::bad_alloc);</p><p>void operator delete(void *) throw();</p><p><strong>分配失败则抛出异常std::bad_alloc，不是返回NULL，所以判断返回值是否为NULL是没用的</strong>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p=new char[size]; //分配失败，不是返回NULL</span><br><span class="line"></span><br><span class="line">delete [] p;</span><br></pre></td></tr></table></figure><p>2.<strong>不抛出异常</strong>。分配失败时，返回NULL。定义如下：</p><blockquote><p>void* operator new(std::size_t,const std::nothrow_t&amp;) throw();</p><p>void operator delete(void*) throw();</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char *p=new(nothrow) char[size]; //分配失败，是返回NULL</span><br><span class="line">if(NULL==p)</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;&quot;alloc failure!&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="new-运算符、函数和替换函数"><a href="#new-运算符、函数和替换函数" class="headerlink" title="new: 运算符、函数和替换函数"></a>new: 运算符、函数和替换函数</h3><p>运算符new 和 new [] 分别调用如下函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void * operator new(std::size_t);//use by new</span><br><span class="line">void * operator new [] (std::size_t);//use by new []</span><br></pre></td></tr></table></figure><p>运算符delete 和 delete [] 分别调用如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span></span>;<span class="comment">//use by delete</span></span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span> [](<span class="type">void</span> *);<span class="comment">//use by delete []</span></span><br></pre></td></tr></table></figure><p>这些函数称为 <strong>分配函数</strong> ，位于全局名称空间中。std::size_t 是一个 typedef。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pi = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">//将转换为下面这样</span></span><br><span class="line"><span class="type">int</span> * pi = <span class="built_in">new</span> (<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * pi = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">40</span>];</span><br><span class="line"><span class="comment">//将转换为下面这样</span></span><br><span class="line"><span class="type">int</span> * pi = <span class="built_in">new</span> (<span class="number">40</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样的</span></span><br><span class="line"><span class="keyword">delete</span> pi;</span><br><span class="line"><span class="comment">//将转换为下面这样</span></span><br><span class="line"><span class="built_in">delete</span> (pi);</span><br></pre></td></tr></table></figure><h3 id="定位-placement-new-运算符"><a href="#定位-placement-new-运算符" class="headerlink" title="定位 placement new 运算符"></a>定位 placement new 运算符</h3><p>通常，new负责在 堆 中分配一个足以满足要求的内存块，但 <strong>定位new可以让程序员指定要使用的内存位置</strong>。不会内存分配失败，因为它根本不分配内存，只调用对象的构造函数。它允许在一块已经分配成功的内存上重新构造对象或对象数组。定义如下：</p><p>void* operator new(size_t,void*);</p><p>void operator delete(void*,void*);</p><p>1.使用 定位new运算符，首先要包含 <strong>头文件 new</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chaff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> dross[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> slag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> buffer1[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> buffer2[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chaff * p1, p2;</span><br><span class="line">    p2 = <span class="built_in">new</span> (buffer1) chaff;<span class="comment">// 在buffer1中</span></span><br><span class="line">    p2 = <span class="built_in">new</span> (buffer2) <span class="type">int</span>[<span class="number">20</span>]; <span class="comment">// 在buffer2中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用placement new构造起来的对象或数组，要<strong>显式调用它们的析构函数</strong>来销毁（析构函数并不释放对象的内存），千万不要使用delete.这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</p><p>3.当使用new运算符定义一个多维数组变量或数组对象时，它产生一个指向数组第一个元素的指针，返回的类型保持了除最左边维数外的所有维数。</p><h2 id="c-引用"><a href="#c-引用" class="headerlink" title="c++引用"></a>c++引用</h2><p>引用是C++的新增内容，在实际开发中会经常使用；C++用的引用就如同C语言的指针一样重要，但它比指针更加方便和易用。</p><p>我们知道，参数的传递本质上是一次赋值的过程，即将一块内存上的数据复制到另一块内存上。<br>对于像 char、bool、int、float 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组、结构体、对象是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率。<br>C&#x2F;C++ 禁止在函数调用时直接传递数组的内容，而是强制传递数组指针。而对于结构体和对象没有这种限制，调用函数时既可以传递指针，也可以直接传递内容；为了提高效率，建议传递指针。<br>但是在 C++ 中，我们有了一种比指针更加便捷的传递聚合类型数据的方式，那就是<strong>引用（Reference）</strong>。</p><hr><h3 id="一，引用的概念"><a href="#一，引用的概念" class="headerlink" title="一，引用的概念"></a><strong>一，引用的概念</strong></h3><p>引用（Reference）是 C++ 相对于C语言的又一个扩充。引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。引用类似于 Windows 中的快捷方式，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序；引用还类似于人的绰号（笔名），使用绰号（笔名）和本名都能表示一个人。<br>引用的定义方式类似于指针，只是**用<code>&amp;</code>取代了<code>*</code>**，语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type &amp;name = data;</span><br></pre></td></tr></table></figure><p>type 是被引用的数据的类型，name 是引用的名称，data 是被引用的数据。引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。</p><p><strong>下面是一个演示引用的实例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; b = a; <span class="comment">//引用定义</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a的地址:&quot;</span> &lt;&lt; &amp;a &lt;&lt;<span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;b的地址:&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/645.png" class="lazyload" data-srcset="/../image/645.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="645"></p><p><strong>需要注意的是：</strong></p><ul><li>引用在定义时需要添加<code>&amp;</code>，在使用时不能添加<code>&amp;</code>，使用时添加<code>&amp;</code>表示取地址。</li><li>对变量b进行修改时，变量a的值也会改变。</li></ul><h3 id="二，引用作为函数参数（将形参和实参绑定）"><a href="#二，引用作为函数参数（将形参和实参绑定）" class="headerlink" title="二，引用作为函数参数（将形参和实参绑定）"></a><strong>二，引用作为函数参数（将形参和实参绑定）</strong></h3><p>引用作为函数参数时有两种原因：</p><ol><li>在函数内部会对此参数进行修改</li><li>提高函数调用和运行效率</li></ol><p><strong>关于第一点：</strong></p><p>都知道C++里提到函数就会提到形参和实参。函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。<strong>即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。</strong>函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。<br><strong>例如：（对两个变量进行交换处理。此处函数的形参为p1, p2，没有引用）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void swap(int p1,int p2)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; //输入a,b两变量的值</span><br><span class="line">    swap(a, b);//直接以变量a和b作为实参调用swap函数</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;//输出结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现输出的a和b还是你输入的值，没有交换。</p><p><strong>修改为：（对两个变量进行交换处理。此处函数的形参为p1, p2都是引用）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void swap(int &amp;p1,int &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; //输入a,b两变量的值</span><br><span class="line">    swap(a, b);//直接以变量a和b作为实参调用swap函数</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;//输出结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行，就会发现值交换了。</p><p>原理就在于采用&amp;p1和&amp;p2时，p1和p2是实参的别名而已，像一个指针指向实参。改变p1和p2就是改变实参的值。</p><p><strong>关于第二点：</strong></p><p>可以结合第一点分析，p1和p2是实参的引用，不用经过值的传递机制，已经有了实参值的信息。所以没有了传值和生成副本的时间和空间消耗。当程序对效率要求比较高时，这是非常必要的.</p><hr><p> <strong>拓展：</strong></p><p>前面演示了<strong>直接转递参数</strong>，和<strong>引用传参</strong>。我们还可以用<strong>传递指针</strong>来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void swap(int *p1,int *p2)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; //输入a,b两变量的值</span><br><span class="line">    swap(&amp;a, &amp;b);//直接以地址作为实参调用swap函数</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;//输出结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三，引用作为函数返回值"><a href="#三，引用作为函数返回值" class="headerlink" title="三，引用作为函数返回值"></a><strong>三，引用作为函数返回值</strong></h3><p>引用除了可以作为函数形参，还可以作为函数返回值。</p><p><strong>说明：</strong></p><p>（1）以引用返回函数值，定义函数时需要在函数名前加&amp;</p><p>（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。</p><p>当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int function1(int&amp; aa)//以返回值的方法返回函数值</span><br><span class="line">&#123;</span><br><span class="line">    return aa;</span><br><span class="line">&#125;</span><br><span class="line">int&amp; function2(int&amp; aa)//以引用方式返回函数值</span><br><span class="line">&#123;</span><br><span class="line">    return aa;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    //第一种情况，系统生成要返回值的副本（即临时变量）</span><br><span class="line">   int b = function1(a);//function1()的返回值先储存在一个临时变量中，</span><br><span class="line">                     //然后再把临时变量赋值给b</span><br><span class="line">   //第二种情况，报错</span><br><span class="line">   // function1(a) = 20;// function1()的返回值为临时变量，不能赋值（即不能为左值）</span><br><span class="line">   //第三种情况，系统不会生成返回值的副本</span><br><span class="line">    function2(a) = 20;//OK  此时a的值变成了20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：若函数的返回值为引用(&amp;)，则编译器就不为返回值创建临时变量了。直接返回那个变量的引用。所以千万不要返回临时变量的引用，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int &amp; function()</span><br><span class="line">&#123;</span><br><span class="line">    int b = 10;</span><br><span class="line">    return b;//不OK 等函数返回后，b就消失了，引用了一个消失的东西</span><br><span class="line">             //程序会懵逼的。指针也一样。</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    a = function();//function()返回的东西已经消失了，引用也就不存在了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>什么是函数重载呢？这里引用一段话</p><p>函数重载是指在同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。</p><blockquote><p>When two or more different declarations are specified for a single name in the same scope, that name is said to <em>overloaded</em>. By extension, two declarations in the same scope that declare the same name but with different types are called <em>overloaded declarations</em>. Only function declarations can be overloaded; object and type declarations cannot be overloaded. ——摘自《ANSI C++ Standard. P290》</p></blockquote><p>下面是一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print a integer :&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print a string :&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>*函数重载的规则：*</strong></em></p><ul><li><strong>函数名称必须相同。</strong></li><li><strong>参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。</strong></li><li><strong>函数的返回类型可以相同也可以不相同。</strong></li><li><strong>仅仅返回类型不同不足以成为函数的重载。</strong></li></ul><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++面向对象的三大特征:封装，继承，多态</p><p>C++认为万事万物皆为对象，对象上有其属性和行为</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p> 在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123; 访问权限： 属性 / 行为 &#125;;</code></p><p>示例一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//权限</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">//属性</span></span><br><span class="line">      <span class="type">int</span> m_r; <span class="comment">// 半径</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//行为</span></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="comment">//获取圆的周长</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>*pi*m_r;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Circle c1;</span><br><span class="line">    c1.m_r =<span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1的周长:&quot;</span>&lt;&lt;c1.<span class="built_in">calculateZC</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public 公共权限</li><li>protected 保护权限</li><li>private 私有权限</li></ol><p>private 私有权限<br>示例：</p><pre><code>//三种权限//公共权限  public     类内可以访问  类外可以访问//保护权限  protected  类内可以访问  类外不可以访问//私有权限  private    类内可以访问  类外不可以访问//protected和private的区别主要体现在继承上//例如：儿子可以访问父亲中protected的内容，但是不可以访问private的内容class Person&#123;    //姓名  公共权限public:    string m_Name;    //汽车  保护权限protected:    string m_Car;    //银行卡密码  私有权限</code></pre><p>​<br>​private:<br>​int m_Password;<br>​<br>​public:<br>​void func()<br>​{<br>​m_Name &#x3D; “张三”;<br>​m_Car &#x3D; “拖拉机”;<br>​m_Password &#x3D; 123456;<br>​}<br>​};<br>​int main() {<br>​Person p;<br>​p.m_Name &#x3D; “李四”;<br>​&#x2F;&#x2F;p.m_Car &#x3D; “奔驰”;  &#x2F;&#x2F;保护权限类外访问不到<br>​&#x2F;&#x2F;p.m_Password &#x3D; 123; &#x2F;&#x2F;私有权限类外访问不到<br>​<br>​system(“pause”);<br>​<br>​return 0;<br>​}</p><p>1.2 struct和class区别<br>在C++中 struct和class唯一的区别就在于 默认的访问权限不同</p><p>区别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 默认权限为公共</span><br><span class="line"><span class="keyword">class</span> 默认权限为私有</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.3 成员属性设置为私有<br><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//姓名设置可读可写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取年龄 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置年龄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置为只写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">m_Lover = lover;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"><span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line">    string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"><span class="comment">//姓名设置</span></span><br><span class="line">p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄设置</span></span><br><span class="line">p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置</span></span><br><span class="line">p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h2><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p><strong>构造函数语法</strong>: 类名(){}</p><p>1.构造函数，没有返回值也不写void</p><p>2.函数名称与类名相同</p><p>3.构造函数可以有参数，因此可以发生重载</p><p>4.程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</p><p><strong>析构函数语法</strong>:~类名(){}</p><p>1.析构函数,没有返回值也不写void</p><p>2.函数名称与类名相同,在名称前加上符号 ~</p><p>3.析构函数不可以有参数，因此不可以发生重载</p><p>4.程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>();</span><br><span class="line">~<span class="built_in">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数的分类及调用</p><p>两种分类方式</p><ul><li>按参数分为 ： 有参构造和无参构造</li><li>按类型分为 ： 普通构造和拷贝构造</li></ul><p>三种调用方式：</p><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//1.构造函数的分类及调用</span></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的有参函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person函数的拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">age = p.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:定义最初始的构造函数的时候不可加();</p><h3 id="拷贝构造函数的时机"><a href="#拷贝构造函数的时机" class="headerlink" title="拷贝构造函数的时机"></a>拷贝构造函数的时机</h3><p>C++中拷贝函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的有参函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person函数的拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">age = p.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p=dWork1;</span><br><span class="line">    cout &lt;&lt;(<span class="type">int</span>*)&amp;p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Person <span class="title">dWork1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    cout &lt;&lt;(<span class="type">int</span>*)&amp;p1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/646.png" class="lazyload" data-srcset="/../image/646.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="646"></p><p>我们发现是创造了一个新的对象</p><h3 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h3><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1.默认构造函数(无参，函数体为空)</p><p>2.默认析构函数(无参,函数体为空)</p><p>3.默认拷贝构造函数,对属性进行值拷贝</p><p>构造函数调用规则如下:</p><ul><li>如果用户定义有参构造函数，c++不再提供默认无参构造函数，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，则c++不再提供其它构造函数</li></ul><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><h4 id="浅拷贝（shallowCopy）："><a href="#浅拷贝（shallowCopy）：" class="headerlink" title="浅拷贝（shallowCopy）："></a>浅拷贝（shallowCopy）：</h4><p>对于基本数据类型和简单对象，他们之间的拷贝非常简单，就是按位复制内存，这种默认的拷贝行为就是浅拷贝，这和<code>memcpy()</code>函数的调用效果类似。</p><h4 id="深拷贝（deepCopy）："><a href="#深拷贝（deepCopy）：" class="headerlink" title="深拷贝（deepCopy）："></a>深拷贝（deepCopy）：</h4><p>深拷贝会将原有对象的所有成员变量拷贝给新对象，对于指针等数据还会为新对象重新在堆上分配一块内存，并将原有对象所持有的堆上的数据也拷贝过来，这样能保证原有对象和新对象所持有的动态内存都是相互独立的，更改一个对象的数据不会影响另一个对象，同时也不会造成<code>double free</code>的错误。</p><h4 id="一个通俗的理解"><a href="#一个通俗的理解" class="headerlink" title="一个通俗的理解"></a>一个通俗的理解</h4><p>浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shallowCopy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shallowCopy</span>(<span class="type">int</span> len) : <span class="built_in">m_len</span>(len) &#123;</span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>); <span class="comment">// m_ptr指向一个值为0的int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shallowCopy</span>() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">shallowCopy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 定义为public，方便输出</span></span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line">    <span class="type">int</span> m_len;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deepCopy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">deepCopy</span>(<span class="type">int</span> len) : <span class="built_in">m_len</span>(len) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call deepCopy(int len) &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deepCopy</span>(<span class="type">const</span> deepCopy&amp; deepcopy) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call deepCopy(const deepCopy&amp; deepcopy) &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_len = deepcopy.m_len;</span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(*(deepcopy.m_ptr)); <span class="comment">// 重新分配内存，并且赋值</span></span><br><span class="line">    &#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">deepCopy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line">    <span class="type">int</span> m_len;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shallowCopy <span class="title">sc</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> sc1 = sc; <span class="comment">// 浅拷贝</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;shallowCopy: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sc.m_ptr = &quot;</span> &lt;&lt; sc.m_ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sc1.m_ptr = &quot;</span> &lt;&lt; sc1.m_ptr &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deepCopy: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">deepCopy <span class="title">dc</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">deepCopy <span class="title">dc1</span><span class="params">(dc)</span></span>; <span class="comment">// 深拷贝</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;dc.m_ptr = &quot;</span> &lt;&lt; dc.m_ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;dc1.m_ptr = &quot;</span> &lt;&lt; dc1.m_ptr &lt;&lt; std::endl;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/648.png" class="lazyload" data-srcset="/../image/648.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="648"></p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><strong>作用</strong>：</p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数(): 属性1(值1)，属性2(值2)...&#123;&#125;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">m_A = a;</span><br><span class="line">m_B = b;</span><br><span class="line">m_C = c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A:&quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_B:&quot;</span> &lt;&lt; p1.m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_C:&quot;</span> &lt;&lt; p1.m_C &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test1</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员</p><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_PName = pName;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">string m_PName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name,string pName): <span class="built_in">m_Name</span>(name),<span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;Person构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//姓名</span></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="comment">//手机</span></span><br><span class="line">Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;iphone14&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt;<span class="string">&quot;拿着&quot;</span> &lt;&lt; p.m_Phone.m_PName &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test1</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/647.png" class="lazyload" data-srcset="/../image/647.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="647"></p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>就是static</p><h2 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h2><h3 id="成员变量和成员函数分开储存"><a href="#成员变量和成员函数分开储存" class="headerlink" title="成员变量和成员函数分开储存"></a>成员变量和成员函数分开储存</h3><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员变量 和成员函数 分开存储的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A; <span class="comment">// 非静态成员变量  属于类的对象上的</span></span><br><span class="line"></span><br><span class="line">string m_C;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">// 静态成员变量  不属于类的对象上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="comment">// 非静态成员函数  不属于类的对象上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="comment">// 静态成员函数 不属实类的对象上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空对象占用的内存空间为：</span></span><br><span class="line"><span class="comment">// C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span></span><br><span class="line"><span class="comment">// 每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// this 指针指向 被调用的成员函数 所属的对象</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddAge</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">// this 指向 p2 的指针，而 *this 指向的就是 p2 这个对象本体</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、返回对象本身用 *this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果调用的函数返回的是 Person</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// p2.PersonAddAge(p1); 修改了 p2 的 age (p2.age += p1.age)</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// p2.PersonAddAge(p1).PersonAddAge(p1); </span></span><br><span class="line"><span class="comment">// 先调用了 p2.PersonAddAge(p1); 返回了一个拷贝 p2 的函数，然后 p2`.PersonAddAge(p1);</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1); </span></span><br><span class="line"><span class="comment">// 先调用了 p2.PersonAddAge(p1); 返回了一个拷贝 p2 的函数，然后 p2`.PersonAddAge(p1), 最后 p2``.PersonAddAge(p1)</span></span><br><span class="line"><span class="comment">// p2` 和 p2`` 均为新创建的函数，不会影响 p2 的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果调用的函数返回的是 Person&amp;</span></span><br><span class="line"><span class="comment">// p2.PersonAddAge(p1); 修改了 p2 的 age (p2.age += p1.age)</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1); 因为返回的是 p2 的地址，所以函数的调用是这样的  </span></span><br><span class="line"><span class="comment">// p2.PersonAddAge(p1); p2.PersonAddAge(p1); p2.PersonAddAge(p1);  相当于 p2 调用了 3 次 PersonAddAge(p1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式编程思想</span></span><br><span class="line">p2.<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空指针调用成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 报错原因是因为传入的指针是为 NULL</span></span><br><span class="line"><span class="comment">// 解决方法，判断指针是否为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">showPersonAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 指针的本质  是指针常量  指针的指向是不可以修改的</span></span><br><span class="line"><span class="comment">// const Person* const this;</span></span><br><span class="line"><span class="comment">// 在成员函数后面加 const，修饰的是 this 指向，让指针指向的值也不可以修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// this-&gt;m_A = 100;</span></span><br><span class="line"><span class="comment">// this = NULL; // this 指针是不可以修改指针的指向的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">// 特殊变量，即使在常函数中，也可以修改这个值，加关键字 mutable</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> Person p; <span class="comment">// 在对象前加 const，变为常对象</span></span><br><span class="line"><span class="comment">// p.m_A = 1100;</span></span><br><span class="line">p.m_B = <span class="number">100</span>; <span class="comment">// m_B 是特殊值，在常对象下也可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常对象只能调用常函数</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line"><span class="comment">//p.func(); // 常对象 不可以调用普通成员函数，因为普通成员函数可以修改属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为 friend</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><p>语法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> [你想实现的方式]</span><br></pre></td></tr></table></figure><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建筑物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// goodGay 全局函数是 Building 好朋友，可以访问 Building 中的私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building* building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">string m_SittingRoom; <span class="comment">// 客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">string m_BedRoom; <span class="comment">// 卧室</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building* building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友全局函数 正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友全局函数 正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Building building;</span><br><span class="line"><span class="built_in">goodGay</span>(&amp;building);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类做友元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">// 参观函数 访问 Building 中的属性</span></span><br><span class="line"></span><br><span class="line">Building* building;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// GoodGay 类是本类的好朋友，可以访问本类中私有</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">string m_SittingRoom; <span class="comment">// 客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">string m_BedRoom; <span class="comment">// 卧室</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外写成员函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建建筑物对象</span></span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GoodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">// 让 visit 函数可以访问 building 中私有成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; <span class="comment">// 让 visit2 函数不可以访问 Building 中私有成员</span></span><br><span class="line"></span><br><span class="line">Building* building;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 告诉编译器 GoodGay 类下的 visit 成员函数作为本类的好朋友，可以访问私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">string m_SittingRoom; <span class="comment">// 客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">string m_BedRoom; <span class="comment">// 卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外实现成员函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;visit 函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;visit 函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;visit2 函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;visit 函数正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GoodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line">gg.<span class="built_in">visit2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加号运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、成员函数重载 + 号</span></span><br><span class="line"><span class="comment">//Person operator+ (Person&amp; p)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//Person temp;</span></span><br><span class="line"><span class="comment">//temp.m_A = this-&gt;m_A + p.m_A;</span></span><br><span class="line"><span class="comment">//temp.m_B = this-&gt;m_B + p.m_B;</span></span><br><span class="line"><span class="comment">//return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的声明</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2);</span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">10</span>;</span><br><span class="line">p1.m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">10</span>;</span><br><span class="line">p2.m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数重载本质调用</span></span><br><span class="line"><span class="comment">// Person p3 = p1.operator+(p2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数重载本质调用</span></span><br><span class="line"><span class="comment">// Person p3 = operator+(p1, p2);</span></span><br><span class="line"></span><br><span class="line">Person p3 = p1 + p2;</span><br><span class="line"><span class="comment">// 运算符重载 也可以发生函数重载</span></span><br><span class="line"></span><br><span class="line">Person p4 = p1 + <span class="number">100</span>; <span class="comment">// Person + int</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3.m_A：&quot;</span> &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3.m_B：&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p4.m_A：&quot;</span> &lt;&lt; p4.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p4.m_B：&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、全局函数重载 + 号</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">temp.m_B = p1.m_B + p2.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载的版本</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p.m_A + num;</span><br><span class="line">temp.m_B = p.m_B + num;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左移运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 友元</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = a;</span><br><span class="line">        m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用成员函数重载 左移运算符  p.operator&lt;&lt;(cout) 简化版本 p &lt;&lt; cout</span></span><br><span class="line">    <span class="comment">// 不会利用成员函数重载 &lt;&lt; 运算符，因为无法实现 cout 在左侧</span></span><br><span class="line">    <span class="comment">//void operator&lt;&lt;(Person&amp; p) </span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能利用全局函数重载左移运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p) <span class="comment">// 本质 operator &lt;&lt; (cout , p)，简化 cout &lt;&lt; p</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p &lt;&lt; <span class="string">&quot; Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p><h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><p>作用： 通过重载递增递减运算符，实现自己的整型数据</p><p>递增示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载递增运算符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义整型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> MyInteger&amp; myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载前置 ++ 运算符  返回引用是为了一直对一个数据进行递增操作</span></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先进行 ++ 运算</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Num++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再将自身返回</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">    <span class="comment">// void operator++(int)  int代表占位参数，可以用于区分前置和后置递增</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先 记录当时结果</span></span><br><span class="line">        MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 后 递增</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Num++;</span><br><span class="line">        <span class="comment">// 最后将记录结果做返回</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载左移运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> MyInteger&amp; myint)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; myint.m_Num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置递增测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ++(++myint) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置递增测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (myint++) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递减示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载递减运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义整型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 友元</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> MyInteger&amp; myInt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置递减</span></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>--()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Num--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置递减</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先记录当前的值</span></span><br><span class="line">        MyInteger temp;</span><br><span class="line">        temp.m_Num = <span class="keyword">this</span>-&gt;m_Num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再进行递减</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Num--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后返回记录的值</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;&lt; 运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> MyInteger&amp; myInt)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; myInt.m_Num &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; --(--myInt) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; myInt-- &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator&#x3D;, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 赋值运算符</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 编译器是提供浅拷贝</span></span><br><span class="line">        <span class="comment">// m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应该先判断是否有属性在堆区，如果有先释放干净，然后深拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回对象本身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p3 = p1 = p2; <span class="comment">// 赋值操作</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3 的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    c = b = a;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载关系运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载  == 号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age &amp;&amp; <span class="keyword">this</span>-&gt;m_Name == p.m_Name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 != 号</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age &amp;&amp; <span class="keyword">this</span>-&gt;m_Name == p.m_Name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 和 p2 是相等的！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 和 p2 是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 != p2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 和 p2 是不相等的！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 和 p2 是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><ul><li>函数调用运算符 () 也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印输出类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint02</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 由于使用起来非常类似函数调用，因此称为仿函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyPrint02</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数非常灵活，没有固定的写法</span></span><br><span class="line"><span class="comment">// 加法类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">myAdd</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名函数对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;new操作符&quot;&gt;&lt;a href=&quot;#new操作符&quot; class=&quot;headerlink&quot; title=&quot;new操作符&quot;&gt;&lt;/a&gt;new操作符&lt;/h2&gt;&lt;h3 id=&quot;使用-new-运算符-分配内存-并-初始化&quot;&gt;&lt;a href=&quot;#使用-new-运算符-分配内存-</summary>
      
    
    
    
    <category term="C++" scheme="https://5m10v3.github.io/categories/C/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AliyunCTF2023-字节码跳动复现</title>
    <link href="https://5m10v3.github.io/2024/04/18/AliyunCTF2023-%E5%AD%97%E8%8A%82%E7%A0%81%E8%B7%B3%E5%8A%A8%E5%A4%8D%E7%8E%B0/"/>
    <id>https://5m10v3.github.io/2024/04/18/AliyunCTF2023-%E5%AD%97%E8%8A%82%E7%A0%81%E8%B7%B3%E5%8A%A8%E5%A4%8D%E7%8E%B0/</id>
    <published>2024-04-17T16:00:00.000Z</published>
    <updated>2024-04-18T17:02:45.024Z</updated>
    
    <content type="html"><![CDATA[<p>复现本题主要是为了学习js字节码，若有不足之处，请各位师傅多多指出</p><p>V8 是 Google 开发的开源 JavaScript 引擎。 Chrome、Node.js和许多其他应用程序都在使用 V8。<br>如果只发布V8引擎编译后的字节码，就可以保护源码。</p><p>可以从下面这篇文章中学习变量声明、条件分支、循环、函数声明、类等最基本语法对应的字节码。</p><p><a href="https://tw.coderbridge.com/series/817c07dc8e1c46f2b0a604b3b4e195c1">https://tw.coderbridge.com/series/817c07dc8e1c46f2b0a604b3b4e195c1</a></p><p>下面这个链接可以当v8的javascript字节码阅读官方文档来用。<br><a href="https://github.com/v8/v8/blob/d84e9496d23cf1dc776ae32199d81accfabaafb5/src/interpreter/interpreter-generator.cc">https://github.com/v8/v8/blob/d84e9496d23cf1dc776ae32199d81accfabaafb5/src/interpreter/interpreter-generator.cc</a></p><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>根据题目给出的bytecode.txt,分析出来它的加密函数已经字符串的比较</p><h3 id="选手获得的文件"><a href="#选手获得的文件" class="headerlink" title="选手获得的文件"></a>选手获得的文件</h3><ul><li>nodejs 二进制程序</li><li>flagchecker.jsc，js源码通过Bytenode编译后得到的字节码形式，能够正常运行</li><li>flagchecker_bytecode.txt，nodejs运行flagchecker.js时添加 <code>-bytecode</code> 获得的js字节码汇编文本文件。</li><li>runner.js、run.sh，用于引导nodejs运行flagchecker.jsc</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们可以根据flagchecker.jsc 的运行结果得出返回值</p><p>Right!  or  Wrong!</p><p>然后我们在海量的函数里面就可以定位到一个函数</p><h3 id="Main函数-剖析字节码"><a href="#Main函数-剖析字节码" class="headerlink" title="Main函数-剖析字节码"></a>Main函数-剖析字节码</h3><p>main函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[generated bytecode <span class="keyword">for</span> <span class="attr">function</span>: main (<span class="number">0x3711a3bdfd81</span> &lt;<span class="title class_">SharedFunctionInfo</span> main&gt;)]</span><br><span class="line"><span class="title class_">Bytecode</span> <span class="attr">length</span>: <span class="number">69</span></span><br><span class="line"><span class="title class_">Parameter</span> count <span class="number">1</span></span><br><span class="line"><span class="title class_">Register</span> count <span class="number">4</span></span><br><span class="line"><span class="title class_">Frame</span> size <span class="number">32</span></span><br><span class="line"><span class="variable constant_">OSR</span> nesting <span class="attr">level</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Bytecode</span> <span class="title class_">Age</span>: <span class="number">0</span></span><br><span class="line"> <span class="number">1207</span> S&gt; <span class="number">0x3711a3be0a56</span> @    <span class="number">0</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a59</span> @    <span class="number">3</span> : c2                <span class="title class_">Star1</span> </span><br><span class="line"> <span class="number">1215</span> E&gt; <span class="number">0x3711a3be0a5a</span> @    <span class="number">4</span> : 2d f9 <span class="number">01</span> <span class="number">02</span>       <span class="title class_">LdaNamedProperty</span> r1, [<span class="number">1</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a5e</span> @    <span class="number">8</span> : c2                <span class="title class_">Star1</span> </span><br><span class="line">         <span class="number">0x3711a3be0a5f</span> @    <span class="number">9</span> : 0d <span class="number">02</span>             <span class="title class_">LdaSmi</span> [<span class="number">2</span>]</span><br><span class="line"> <span class="number">1219</span> E&gt; <span class="number">0x3711a3be0a61</span> @   <span class="number">11</span> : 2f f9 <span class="number">04</span>          <span class="title class_">LdaKeyedProperty</span> r1, [<span class="number">4</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a64</span> @   <span class="number">14</span> : c3                <span class="title class_">Star0</span> </span><br><span class="line"> <span class="number">1270</span> S&gt; <span class="number">0x3711a3be0a65</span> @   <span class="number">15</span> : <span class="number">96</span> <span class="number">23</span>             <span class="title class_">JumpIfToBooleanFalse</span> [<span class="number">35</span>] (<span class="number">0x3711a3be0a88</span> @ <span class="number">50</span>)</span><br><span class="line">         <span class="number">0x3711a3be0a67</span> @   <span class="number">17</span> : <span class="number">17</span> <span class="number">03</span>             <span class="title class_">LdaImmutableCurrentContextSlot</span> [<span class="number">3</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a69</span> @   <span class="number">19</span> : c2                <span class="title class_">Star1</span> </span><br><span class="line"> <span class="number">1279</span> E&gt; <span class="number">0x3711a3be0a6a</span> @   <span class="number">20</span> : <span class="number">61</span> f9 fa <span class="number">06</span>       <span class="title class_">CallUndefinedReceiver1</span> r1, r0, [<span class="number">6</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a6e</span> @   <span class="number">24</span> : c2                <span class="title class_">Star1</span> </span><br><span class="line">         <span class="number">0x3711a3be0a6f</span> @   <span class="number">25</span> : <span class="number">11</span>                <span class="title class_">LdaTrue</span> </span><br><span class="line"> <span class="number">1286</span> E&gt; <span class="number">0x3711a3be0a70</span> @   <span class="number">26</span> : 6a f9 <span class="number">08</span>          <span class="title class_">TestEqual</span> r1, [<span class="number">8</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a73</span> @   <span class="number">29</span> : <span class="number">98</span> <span class="number">15</span>             <span class="title class_">JumpIfFalse</span> [<span class="number">21</span>] (<span class="number">0x3711a3be0a88</span> @ <span class="number">50</span>)</span><br><span class="line"> <span class="number">1305</span> S&gt; <span class="number">0x3711a3be0a75</span> @   <span class="number">31</span> : <span class="number">21</span> <span class="number">02</span> <span class="number">09</span>          <span class="title class_">LdaGlobal</span> [<span class="number">2</span>], [<span class="number">9</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a78</span> @   <span class="number">34</span> : c1                <span class="title class_">Star2</span> </span><br><span class="line"> <span class="number">1313</span> E&gt; <span class="number">0x3711a3be0a79</span> @   <span class="number">35</span> : 2d f8 <span class="number">03</span> 0b       <span class="title class_">LdaNamedProperty</span> r2, [<span class="number">3</span>], [<span class="number">11</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a7d</span> @   <span class="number">39</span> : c2                <span class="title class_">Star1</span> </span><br><span class="line">         <span class="number">0x3711a3be0a7e</span> @   <span class="number">40</span> : <span class="number">13</span> <span class="number">04</span>             <span class="title class_">LdaConstant</span> [<span class="number">4</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a80</span> @   <span class="number">42</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line"> <span class="number">1313</span> E&gt; <span class="number">0x3711a3be0a81</span> @   <span class="number">43</span> : 5d f9 f8 f7 0d    <span class="title class_">CallProperty1</span> r1, r2, r3, [<span class="number">13</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a86</span> @   <span class="number">48</span> : <span class="number">89</span> <span class="number">13</span>             <span class="title class_">Jump</span> [<span class="number">19</span>] (<span class="number">0x3711a3be0a99</span> @ <span class="number">67</span>)</span><br><span class="line"> <span class="number">1349</span> S&gt; <span class="number">0x3711a3be0a88</span> @   <span class="number">50</span> : <span class="number">21</span> <span class="number">02</span> <span class="number">09</span>          <span class="title class_">LdaGlobal</span> [<span class="number">2</span>], [<span class="number">9</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a8b</span> @   <span class="number">53</span> : c1                <span class="title class_">Star2</span> </span><br><span class="line"> <span class="number">1357</span> E&gt; <span class="number">0x3711a3be0a8c</span> @   <span class="number">54</span> : 2d f8 <span class="number">03</span> 0b       <span class="title class_">LdaNamedProperty</span> r2, [<span class="number">3</span>], [<span class="number">11</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a90</span> @   <span class="number">58</span> : c2                <span class="title class_">Star1</span> </span><br><span class="line">         <span class="number">0x3711a3be0a91</span> @   <span class="number">59</span> : <span class="number">13</span> <span class="number">05</span>             <span class="title class_">LdaConstant</span> [<span class="number">5</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a93</span> @   <span class="number">61</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line"> <span class="number">1357</span> E&gt; <span class="number">0x3711a3be0a94</span> @   <span class="number">62</span> : 5d f9 f8 f7 0f    <span class="title class_">CallProperty1</span> r1, r2, r3, [<span class="number">15</span>]</span><br><span class="line">         <span class="number">0x3711a3be0a99</span> @   <span class="number">67</span> : 0e                <span class="title class_">LdaUndefined</span> </span><br><span class="line"> <span class="number">1378</span> S&gt; <span class="number">0x3711a3be0a9a</span> @   <span class="number">68</span> : a8                <span class="title class_">Return</span> </span><br><span class="line"><span class="title class_">Constant</span> pool (size = <span class="number">6</span>)</span><br><span class="line"><span class="number">0x3711a3be09e1</span>: [<span class="title class_">FixedArray</span>] <span class="keyword">in</span> <span class="title class_">OldSpace</span></span><br><span class="line"> - <span class="attr">map</span>: <span class="number">0x2546cb1c12c1</span> &lt;<span class="title class_">Map</span>&gt;</span><br><span class="line"> - <span class="attr">length</span>: <span class="number">6</span></span><br><span class="line">           <span class="number">0</span>: <span class="number">0x39ea5930f9e9</span> &lt;<span class="title class_">String</span>[<span class="number">7</span>]: #process&gt;</span><br><span class="line">           <span class="number">1</span>: <span class="number">0x20e3b754b6d9</span> &lt;<span class="title class_">String</span>[<span class="number">4</span>]: #argv&gt;</span><br><span class="line">           <span class="number">2</span>: <span class="number">0x26784b2e1619</span> &lt;<span class="title class_">String</span>[<span class="number">7</span>]: #<span class="variable language_">console</span>&gt;</span><br><span class="line">           <span class="number">3</span>: <span class="number">0x0ef123a28e69</span> &lt;<span class="title class_">String</span>[<span class="number">3</span>]: #log&gt;</span><br><span class="line">           <span class="number">4</span>: <span class="number">0x3711a3be0961</span> &lt;<span class="title class_">String</span>[<span class="number">6</span>]: #<span class="title class_">Right</span>!&gt;</span><br><span class="line">           <span class="number">5</span>: <span class="number">0x3711a3be0979</span> &lt;<span class="title class_">String</span>[<span class="number">6</span>]: #<span class="title class_">Wrong</span>!&gt;</span><br><span class="line"><span class="title class_">Handler</span> <span class="title class_">Table</span> (size = <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Source</span> <span class="title class_">Position</span> <span class="title class_">Table</span> (size = <span class="number">31</span>)</span><br><span class="line"><span class="number">0x3711a3be0aa1</span> &lt;<span class="title class_">ByteArray</span>[<span class="number">31</span>]&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LdaGlobal [0], [0]//定义全局变量console 它的第一个参数从Constant pool取,并存储到acc寄存器,acc=global.process</span><br><span class="line">Star1 // r1=acc</span><br><span class="line">LdaNamedProperty r1, [1], [2] //第一个参数表示要作用的对象，第二个参数就是取Constant pool里面的值，第三个参数就是参数的数量</span><br><span class="line">Star1  // r1=global.process.argv</span><br><span class="line">LdaSmi [2] //acc=2</span><br><span class="line">LdaKeyedProperty r1, [4] // acc=global.process.argv[2]</span><br><span class="line">Star0 //r0=acc</span><br><span class="line">JumpIfToBooleanFalse [35] (0x3711a3be0a88 @ 50) //作用是判空，如果结果为false ，就会返回Wrong!</span><br><span class="line">LdaImmutableCurrentContextSlot [3] //调用外部函数</span><br><span class="line">Star1 </span><br><span class="line">CallUndefinedReceiver1 r1, r0, [6]  //调用外部函数 acc=某外部函数</span><br><span class="line">Star1 //r1=acc  </span><br><span class="line">//调用r1，参数个数为1，参数放在r0，即调用某外部函数(global.process.argv[2])</span><br><span class="line">LdaTrue // acc=true</span><br><span class="line">TestEqual r1, [8] // 判断r1是否和acc寄存器相等</span><br><span class="line">JumpIfFalse [21] (0x3711a3be0a88 @ 50)  //如果结果为false ，就会返回Wrong!</span><br><span class="line">//因为上述字节码有个相同的结果，所以在此统一解释一下</span><br><span class="line">1349 S&gt; 0x3711a3be0a88 @   50 : 21 02 09           LdaGlobal [2], [9]</span><br><span class="line">         0x3711a3be0a8b @   53 : c1                Star2 </span><br><span class="line"> 1357 E&gt; 0x3711a3be0a8c @   54 : 2d f8 03 0b       LdaNamedProperty r2, [3], [11]</span><br><span class="line">         0x3711a3be0a90 @   58 : c2                Star1 </span><br><span class="line">         0x3711a3be0a91 @   59 : 13 05             LdaConstant [5]</span><br><span class="line">         0x3711a3be0a93 @   61 : c0                Star3 </span><br><span class="line"> 1357 E&gt; 0x3711a3be0a94 @   62 : 5d f9 f8 f7 0f    CallProperty1 r1, r2, r3, [15]</span><br><span class="line"> 翻译一下就是  :   console.log(&#x27;Wrong!&#x27;) //就是会输出Wrong！</span><br><span class="line"> //下面结构跟上面相似</span><br><span class="line"> 1305 S&gt; 0x3711a3be0a75 @   31 : 21 02 09          LdaGlobal [2], [9]</span><br><span class="line">         0x3711a3be0a78 @   34 : c1                Star2 </span><br><span class="line"> 1313 E&gt; 0x3711a3be0a79 @   35 : 2d f8 03 0b       LdaNamedProperty r2, [3], [11]</span><br><span class="line">         0x3711a3be0a7d @   39 : c2                Star1 </span><br><span class="line">         0x3711a3be0a7e @   40 : 13 04             LdaConstant [4]</span><br><span class="line">         0x3711a3be0a80 @   42 : c0                Star3 </span><br><span class="line"> 1313 E&gt; 0x3711a3be0a81 @   43 : 5d f9 f8 f7 0d    CallProperty1 r1, r2, r3, [13]</span><br><span class="line"> 翻译一下就是   :  console.log(&#x27;Right!&#x27;) //就是会输出Right！</span><br></pre></td></tr></table></figure><p> 可见这个main函数的关键就是外部调用的函数</p><p>我们在海量的函数找到其它两个可以函数 aaa,ccc函数</p><h3 id="aaa函数-剖析字节码"><a href="#aaa函数-剖析字节码" class="headerlink" title="aaa函数-剖析字节码"></a>aaa函数-剖析字节码</h3><p>aaa函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[generated bytecode <span class="keyword">for</span> <span class="attr">function</span>: aaa (<span class="number">0x3711a3bdfd31</span> &lt;<span class="title class_">SharedFunctionInfo</span> aaa&gt;)]</span><br><span class="line"><span class="title class_">Bytecode</span> <span class="attr">length</span>: <span class="number">91</span></span><br><span class="line"><span class="title class_">Parameter</span> count <span class="number">2</span></span><br><span class="line"><span class="title class_">Register</span> count <span class="number">7</span></span><br><span class="line"><span class="title class_">Frame</span> size <span class="number">56</span></span><br><span class="line"><span class="variable constant_">OSR</span> nesting <span class="attr">level</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Bytecode</span> <span class="title class_">Age</span>: <span class="number">0</span></span><br><span class="line">  <span class="number">757</span> S&gt; <span class="number">0x3711a3be0cde</span> @    <span class="number">0</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">         <span class="number">0x3711a3be0ce1</span> @    <span class="number">3</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line">  <span class="number">768</span> E&gt; <span class="number">0x3711a3be0ce2</span> @    <span class="number">4</span> : 2d f7 <span class="number">01</span> <span class="number">02</span>       <span class="title class_">LdaNamedProperty</span> r3, [<span class="number">1</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be0ce6</span> @    <span class="number">8</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line">         <span class="number">0x3711a3be0ce7</span> @    <span class="number">9</span> : 0b f7             <span class="title class_">Ldar</span> r3</span><br><span class="line">  <span class="number">757</span> E&gt; <span class="number">0x3711a3be0ce9</span> @   <span class="number">11</span> : <span class="number">68</span> f7 <span class="number">03</span> <span class="number">01</span> <span class="number">04</span>    <span class="title class_">Construct</span> r3, a0-a0, [<span class="number">4</span>]</span><br><span class="line">         <span class="number">0x3711a3be0cee</span> @   <span class="number">16</span> : c3                <span class="title class_">Star0</span> </span><br><span class="line">  <span class="number">792</span> S&gt; <span class="number">0x3711a3be0cef</span> @   <span class="number">17</span> : 2d fa <span class="number">02</span> <span class="number">06</span>       <span class="title class_">LdaNamedProperty</span> r0, [<span class="number">2</span>], [<span class="number">6</span>]</span><br><span class="line">         <span class="number">0x3711a3be0cf3</span> @   <span class="number">21</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line">         <span class="number">0x3711a3be0cf4</span> @   <span class="number">22</span> : 0d 2b             <span class="title class_">LdaSmi</span> [<span class="number">43</span>]</span><br><span class="line">  <span class="number">799</span> E&gt; <span class="number">0x3711a3be0cf6</span> @   <span class="number">24</span> : 6a f7 <span class="number">08</span>          <span class="title class_">TestEqual</span> r3, [<span class="number">8</span>]</span><br><span class="line">         <span class="number">0x3711a3be0cf9</span> @   <span class="number">27</span> : <span class="number">97</span> <span class="number">04</span>             <span class="title class_">JumpIfTrue</span> [<span class="number">4</span>] (<span class="number">0x3711a3be0cfd</span> @ <span class="number">31</span>)</span><br><span class="line">  <span class="number">806</span> S&gt; <span class="number">0x3711a3be0cfb</span> @   <span class="number">29</span> : <span class="number">12</span>                <span class="title class_">LdaFalse</span> </span><br><span class="line">  <span class="number">819</span> S&gt; <span class="number">0x3711a3be0cfc</span> @   <span class="number">30</span> : a8                <span class="title class_">Return</span> </span><br><span class="line">  <span class="number">835</span> S&gt; <span class="number">0x3711a3be0cfd</span> @   <span class="number">31</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d00</span> @   <span class="number">34</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line">  <span class="number">846</span> E&gt; <span class="number">0x3711a3be0d01</span> @   <span class="number">35</span> : 2d f7 <span class="number">03</span> <span class="number">09</span>       <span class="title class_">LdaNamedProperty</span> r3, [<span class="number">3</span>], [<span class="number">9</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d05</span> @   <span class="number">39</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line">         <span class="number">0x3711a3be0d06</span> @   <span class="number">40</span> : 0d 2b             <span class="title class_">LdaSmi</span> [<span class="number">43</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d08</span> @   <span class="number">42</span> : bf                <span class="title class_">Star4</span> </span><br><span class="line">         <span class="number">0x3711a3be0d09</span> @   <span class="number">43</span> : 0b f7             <span class="title class_">Ldar</span> r3</span><br><span class="line">  <span class="number">835</span> E&gt; <span class="number">0x3711a3be0d0b</span> @   <span class="number">45</span> : <span class="number">68</span> f7 f6 <span class="number">01</span> 0b    <span class="title class_">Construct</span> r3, r4-r4, [<span class="number">11</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d10</span> @   <span class="number">50</span> : c2                <span class="title class_">Star1</span> </span><br><span class="line">  <span class="number">942</span> S&gt; <span class="number">0x3711a3be0d11</span> @   <span class="number">51</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d14</span> @   <span class="number">54</span> : bf                <span class="title class_">Star4</span> </span><br><span class="line">  <span class="number">949</span> E&gt; <span class="number">0x3711a3be0d15</span> @   <span class="number">55</span> : 2d f6 <span class="number">01</span> <span class="number">02</span>       <span class="title class_">LdaNamedProperty</span> r4, [<span class="number">1</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d19</span> @   <span class="number">59</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line">         <span class="number">0x3711a3be0d1a</span> @   <span class="number">60</span> : <span class="number">13</span> <span class="number">04</span>             <span class="title class_">LdaConstant</span> [<span class="number">4</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d1c</span> @   <span class="number">62</span> : be                <span class="title class_">Star5</span> </span><br><span class="line">         <span class="number">0x3711a3be0d1d</span> @   <span class="number">63</span> : <span class="number">13</span> <span class="number">05</span>             <span class="title class_">LdaConstant</span> [<span class="number">5</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d1f</span> @   <span class="number">65</span> : bd                <span class="title class_">Star6</span> </span><br><span class="line">  <span class="number">949</span> E&gt; <span class="number">0x3711a3be0d20</span> @   <span class="number">66</span> : 5e f7 f6 f5 f4 0d <span class="title class_">CallProperty2</span> r3, r4, r5, r6, [<span class="number">13</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d26</span> @   <span class="number">72</span> : c1                <span class="title class_">Star2</span> </span><br><span class="line"> <span class="number">1056</span> S&gt; <span class="number">0x3711a3be0d27</span> @   <span class="number">73</span> : <span class="number">17</span> <span class="number">02</span>             <span class="title class_">LdaImmutableCurrentContextSlot</span> [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be0d29</span> @   <span class="number">75</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line">         <span class="number">0x3711a3be0d2a</span> @   <span class="number">76</span> : <span class="number">19</span> fa f6          <span class="title class_">Mov</span> r0, r4</span><br><span class="line">         <span class="number">0x3711a3be0d2d</span> @   <span class="number">79</span> : <span class="number">19</span> f9 f5          <span class="title class_">Mov</span> r1, r5</span><br><span class="line">         <span class="number">0x3711a3be0d30</span> @   <span class="number">82</span> : <span class="number">19</span> f8 f4          <span class="title class_">Mov</span> r2, r6</span><br><span class="line"> <span class="number">1063</span> E&gt; <span class="number">0x3711a3be0d33</span> @   <span class="number">85</span> : 5f f7 f6 <span class="number">03</span> 0f    <span class="title class_">CallUndefinedReceiver</span> r3, r4-r6, [<span class="number">15</span>]</span><br><span class="line"> <span class="number">1087</span> S&gt; <span class="number">0x3711a3be0d38</span> @   <span class="number">90</span> : a8                <span class="title class_">Return</span> </span><br><span class="line"><span class="title class_">Constant</span> pool (size = <span class="number">6</span>)</span><br><span class="line"><span class="number">0x3711a3be0c69</span>: [<span class="title class_">FixedArray</span>] <span class="keyword">in</span> <span class="title class_">OldSpace</span></span><br><span class="line"> - <span class="attr">map</span>: <span class="number">0x2546cb1c12c1</span> &lt;<span class="title class_">Map</span>&gt;</span><br><span class="line"> - <span class="attr">length</span>: <span class="number">6</span></span><br><span class="line">           <span class="number">0</span>: <span class="number">0x3adf78836561</span> &lt;<span class="title class_">String</span>[<span class="number">6</span>]: #<span class="title class_">Buffer</span>&gt;</span><br><span class="line">           <span class="number">1</span>: <span class="number">0x2546cb1c4999</span> &lt;<span class="title class_">String</span>[<span class="number">4</span>]: #<span class="keyword">from</span>&gt;</span><br><span class="line">           <span class="number">2</span>: <span class="number">0x2546cb1c4d41</span> &lt;<span class="title class_">String</span>[<span class="number">6</span>]: #length&gt;</span><br><span class="line">           <span class="number">3</span>: <span class="number">0x3adf78836c31</span> &lt;<span class="title class_">String</span>[<span class="number">5</span>]: #alloc&gt;</span><br><span class="line">           <span class="number">4</span>: <span class="number">0x3711a3be0bb1</span> &lt;<span class="title class_">String</span>[<span class="number">86</span>]: #3edd7925cd6e04ab44f25bef57bc53bd20b74b8c11f893090fdcdfddad0709100100fe6a9230333234fbae&gt;</span><br><span class="line">           <span class="number">5</span>: <span class="number">0x3adf78838741</span> &lt;<span class="title class_">String</span>[<span class="number">3</span>]: #hex&gt;</span><br><span class="line"><span class="title class_">Handler</span> <span class="title class_">Table</span> (size = <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Source</span> <span class="title class_">Position</span> <span class="title class_">Table</span> (size = <span class="number">38</span>)</span><br><span class="line"><span class="number">0x3711a3be0d41</span> &lt;<span class="title class_">ByteArray</span>[<span class="number">38</span>]&gt;</span><br></pre></td></tr></table></figure><p>由于上面的简单铺垫，接下来我们将快速且简洁地分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">LdaGlobal [0], [0]</span><br><span class="line">Star3  // r3 =Buffer  </span><br><span class="line">LdaNamedProperty r3, [1], [2]</span><br><span class="line">Star3  //r3=Buffer.from</span><br><span class="line">Ldar r3  //acc=r3=Buffer.from</span><br><span class="line">Construct r3, a0-a0, [4] //文档的意思是创建 r3 这个函数 ，然后参数是 a0</span><br><span class="line">Star0 //r0= new Buffer.from(a0)</span><br><span class="line">//猜测此处的a0就是main传进来的用户输入。姑且称为input。</span><br><span class="line">LdaNamedProperty r0, [2], [6]</span><br><span class="line">Star3 // r3= input.length</span><br><span class="line">LdaSmi [43] // acc=43</span><br><span class="line">TestEqual r3, [8]  // if input.length == 43</span><br><span class="line">JumpIfTrue [4] (0x3711a3be0cfd @ 31) //如果返回True </span><br><span class="line">LdaFalse //acc=False</span><br><span class="line">Return //返回</span><br><span class="line">LdaGlobal [0], [0] // acc =Buffer</span><br><span class="line">Star3 //r3=acc=Buffer</span><br><span class="line"> 846 E&gt; 0x3711a3be0d01 @   35 : 2d f7 03 09       LdaNamedProperty r3, [3], [9]</span><br><span class="line">        0x3711a3be0d05 @   39 : c0                Star3 </span><br><span class="line">        0x3711a3be0d06 @   40 : 0d 2b             LdaSmi [43]</span><br><span class="line">        0x3711a3be0d08 @   42 : bf                Star4 </span><br><span class="line">        0x3711a3be0d09 @   43 : 0b f7             Ldar r3</span><br><span class="line"> 835 E&gt; 0x3711a3be0d0b @   45 : 68 f7 f6 01 0b    Construct r3, r4-r4, [11]</span><br><span class="line">        0x3711a3be0d10 @   50 : c2                Star1 </span><br><span class="line">//这个函数 翻译一下就是 r1=new Buffer.alloc(43)    </span><br><span class="line">LdaSmi [43]</span><br><span class="line">Star4  //r4 =Buffer</span><br><span class="line">LdaNamedProperty r4, [1], [2]</span><br><span class="line">Star3 //r3=Buffer.from</span><br><span class="line">LdaConstant [4]</span><br><span class="line">Star5 //r5 = &#x27;3edd7925cd6e04ab44f25bef57bc53bd20b74b8c11f893090fdcdfddad0709100100fe6a9230333234fbae&#x27;</span><br><span class="line">LdaConstant [5]</span><br><span class="line">Star6  r6 = hex</span><br><span class="line">CallProperty2 r3, r4, r5, r6, [13]</span><br><span class="line">Star2 //r2=Buffer.from(r5,hex)</span><br><span class="line">LdaImmutableCurrentContextSlot [2]</span><br><span class="line">Star3 //r3=外部函数</span><br><span class="line">Mov r0, r4 // r4=r0</span><br><span class="line">Mov r1, r5 // r5=r1</span><br><span class="line">Mov r2, r6 // r6=r2</span><br><span class="line">CallUndefinedReceiver r3, r4-r6, [15]</span><br><span class="line">Return  //return r3(r4,r5,r6)</span><br></pre></td></tr></table></figure><p>经过剖析我们可以得知，aaa这个函数更像一个初始化的函数，那么看来这个外部函数才是加密的关键</p><h3 id="ccc函数-剖析字节码"><a href="#ccc函数-剖析字节码" class="headerlink" title="ccc函数-剖析字节码"></a>ccc函数-剖析字节码</h3><p>ccc函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">[generated bytecode <span class="keyword">for</span> <span class="attr">function</span>: ccc (<span class="number">0x3711a3bdfce1</span> &lt;<span class="title class_">SharedFunctionInfo</span> ccc&gt;)]</span><br><span class="line"><span class="title class_">Bytecode</span> <span class="attr">length</span>: <span class="number">188</span></span><br><span class="line"><span class="title class_">Parameter</span> count <span class="number">4</span></span><br><span class="line"><span class="title class_">Register</span> count <span class="number">4</span></span><br><span class="line"><span class="title class_">Frame</span> size <span class="number">32</span></span><br><span class="line"><span class="variable constant_">OSR</span> nesting <span class="attr">level</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Bytecode</span> <span class="title class_">Age</span>: <span class="number">0</span></span><br><span class="line">  <span class="number">173</span> S&gt; <span class="number">0x3711a3be1216</span> @    <span class="number">0</span> : <span class="number">00</span> 0d aa <span class="number">00</span>       <span class="title class_">LdaSmi</span>.<span class="property">Wide</span> [<span class="number">170</span>]</span><br><span class="line">         <span class="number">0x3711a3be121a</span> @    <span class="number">4</span> : c3                <span class="title class_">Star0</span> </span><br><span class="line">  <span class="number">188</span> S&gt; <span class="number">0x3711a3be121b</span> @    <span class="number">5</span> : 0c                <span class="title class_">LdaZero</span> </span><br><span class="line">  <span class="number">189</span> E&gt; <span class="number">0x3711a3be121c</span> @    <span class="number">6</span> : <span class="number">23</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">StaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">  <span class="number">194</span> S&gt; <span class="number">0x3711a3be121f</span> @    <span class="number">9</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be1222</span> @   <span class="number">12</span> : c1                <span class="title class_">Star2</span> </span><br><span class="line">         <span class="number">0x3711a3be1223</span> @   <span class="number">13</span> : 0d <span class="number">13</span>             <span class="title class_">LdaSmi</span> [<span class="number">19</span>]</span><br><span class="line">  <span class="number">194</span> E&gt; <span class="number">0x3711a3be1225</span> @   <span class="number">15</span> : 6c f8 <span class="number">04</span>          <span class="title class_">TestLessThan</span> r2, [<span class="number">4</span>]</span><br><span class="line">         <span class="number">0x3711a3be1228</span> @   <span class="number">18</span> : <span class="number">98</span> 2a             <span class="title class_">JumpIfFalse</span> [<span class="number">42</span>] (<span class="number">0x3711a3be1252</span> @ <span class="number">60</span>)</span><br><span class="line">  <span class="number">274</span> S&gt; <span class="number">0x3711a3be122a</span> @   <span class="number">20</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">  <span class="number">273</span> E&gt; <span class="number">0x3711a3be122d</span> @   <span class="number">23</span> : 2f <span class="number">03</span> <span class="number">06</span>          <span class="title class_">LdaKeyedProperty</span> a0, [<span class="number">6</span>]</span><br><span class="line">  <span class="number">265</span> E&gt; <span class="number">0x3711a3be1230</span> @   <span class="number">26</span> : <span class="number">38</span> fa <span class="number">08</span>          <span class="title class_">Add</span> r0, [<span class="number">8</span>]</span><br><span class="line">  <span class="number">277</span> E&gt; <span class="number">0x3711a3be1233</span> @   <span class="number">29</span> : <span class="number">44</span> <span class="number">33</span> <span class="number">09</span>          <span class="title class_">AddSmi</span> [<span class="number">51</span>], [<span class="number">9</span>]</span><br><span class="line">  <span class="number">285</span> E&gt; <span class="number">0x3711a3be1236</span> @   <span class="number">32</span> : <span class="number">00</span> 4c ff <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="title class_">BitwiseAndSmi</span>.<span class="property">Wide</span> [<span class="number">255</span>], [<span class="number">5</span>]</span><br><span class="line">         <span class="number">0x3711a3be123c</span> @   <span class="number">38</span> : c3                <span class="title class_">Star0</span> </span><br><span class="line">  <span class="number">305</span> S&gt; <span class="number">0x3711a3be123d</span> @   <span class="number">39</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be1240</span> @   <span class="number">42</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line">         <span class="number">0x3711a3be1241</span> @   <span class="number">43</span> : 0b fa             <span class="title class_">Ldar</span> r0</span><br><span class="line">  <span class="number">308</span> E&gt; <span class="number">0x3711a3be1243</span> @   <span class="number">45</span> : <span class="number">34</span> <span class="number">04</span> f7 0a       <span class="title class_">StaKeyedProperty</span> a1, r3, [<span class="number">10</span>]</span><br><span class="line">  <span class="number">200</span> S&gt; <span class="number">0x3711a3be1247</span> @   <span class="number">49</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be124a</span> @   <span class="number">52</span> : <span class="number">50</span> 0c             <span class="title class_">Inc</span> [<span class="number">12</span>]</span><br><span class="line">  <span class="number">200</span> E&gt; <span class="number">0x3711a3be124c</span> @   <span class="number">54</span> : <span class="number">23</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">StaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">  <span class="number">183</span> E&gt; <span class="number">0x3711a3be124f</span> @   <span class="number">57</span> : <span class="number">88</span> <span class="number">30</span> <span class="number">00</span>          <span class="title class_">JumpLoop</span> [<span class="number">48</span>], [<span class="number">0</span>] (<span class="number">0x3711a3be121f</span> @ <span class="number">9</span>)</span><br><span class="line">  <span class="number">337</span> S&gt; <span class="number">0x3711a3be1252</span> @   <span class="number">60</span> : 0d <span class="number">55</span>             <span class="title class_">LdaSmi</span> [<span class="number">85</span>]</span><br><span class="line">         <span class="number">0x3711a3be1254</span> @   <span class="number">62</span> : c2                <span class="title class_">Star1</span> </span><br><span class="line">  <span class="number">352</span> S&gt; <span class="number">0x3711a3be1255</span> @   <span class="number">63</span> : 0d <span class="number">13</span>             <span class="title class_">LdaSmi</span> [<span class="number">19</span>]</span><br><span class="line">  <span class="number">353</span> E&gt; <span class="number">0x3711a3be1257</span> @   <span class="number">65</span> : <span class="number">23</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">StaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">  <span class="number">359</span> S&gt; <span class="number">0x3711a3be125a</span> @   <span class="number">68</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be125d</span> @   <span class="number">71</span> : c1                <span class="title class_">Star2</span> </span><br><span class="line">         <span class="number">0x3711a3be125e</span> @   <span class="number">72</span> : 0d 2b             <span class="title class_">LdaSmi</span> [<span class="number">43</span>]</span><br><span class="line">  <span class="number">359</span> E&gt; <span class="number">0x3711a3be1260</span> @   <span class="number">74</span> : 6c f8 0d          <span class="title class_">TestLessThan</span> r2, [<span class="number">13</span>]</span><br><span class="line">         <span class="number">0x3711a3be1263</span> @   <span class="number">77</span> : <span class="number">98</span> <span class="number">34</span>             <span class="title class_">JumpIfFalse</span> [<span class="number">52</span>] (<span class="number">0x3711a3be1297</span> @ <span class="number">129</span>)</span><br><span class="line">  <span class="number">383</span> S&gt; <span class="number">0x3711a3be1265</span> @   <span class="number">79</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be1268</span> @   <span class="number">82</span> : c0                <span class="title class_">Star3</span> </span><br><span class="line">  <span class="number">403</span> E&gt; <span class="number">0x3711a3be1269</span> @   <span class="number">83</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">  <span class="number">402</span> E&gt; <span class="number">0x3711a3be126c</span> @   <span class="number">86</span> : 2f <span class="number">03</span> <span class="number">10</span>          <span class="title class_">LdaKeyedProperty</span> a0, [<span class="number">16</span>]</span><br><span class="line">  <span class="number">394</span> E&gt; <span class="number">0x3711a3be126f</span> @   <span class="number">89</span> : <span class="number">38</span> f9 0f          <span class="title class_">Add</span> r1, [<span class="number">15</span>]</span><br><span class="line">  <span class="number">407</span> E&gt; <span class="number">0x3711a3be1272</span> @   <span class="number">92</span> : <span class="number">00</span> 4c ff <span class="number">00</span> 0e <span class="number">00</span> <span class="title class_">BitwiseAndSmi</span>.<span class="property">Wide</span> [<span class="number">255</span>], [<span class="number">14</span>]</span><br><span class="line">  <span class="number">386</span> E&gt; <span class="number">0x3711a3be1278</span> @   <span class="number">98</span> : <span class="number">34</span> <span class="number">04</span> f7 <span class="number">12</span>       <span class="title class_">StaKeyedProperty</span> a1, r3, [<span class="number">18</span>]</span><br><span class="line">  <span class="number">442</span> S&gt; <span class="number">0x3711a3be127c</span> @  <span class="number">102</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">  <span class="number">441</span> E&gt; <span class="number">0x3711a3be127f</span> @  <span class="number">105</span> : 2f <span class="number">04</span> <span class="number">16</span>          <span class="title class_">LdaKeyedProperty</span> a1, [<span class="number">22</span>]</span><br><span class="line">  <span class="number">436</span> E&gt; <span class="number">0x3711a3be1282</span> @  <span class="number">108</span> : 3f f9 <span class="number">15</span>          <span class="title class_">BitwiseXor</span> r1, [<span class="number">21</span>]</span><br><span class="line">  <span class="number">446</span> E&gt; <span class="number">0x3711a3be1285</span> @  <span class="number">111</span> : <span class="number">00</span> 4c ff <span class="number">00</span> <span class="number">14</span> <span class="number">00</span> <span class="title class_">BitwiseAndSmi</span>.<span class="property">Wide</span> [<span class="number">255</span>], [<span class="number">20</span>]</span><br><span class="line">         <span class="number">0x3711a3be128b</span> @  <span class="number">117</span> : c2                <span class="title class_">Star1</span> </span><br><span class="line">  <span class="number">365</span> S&gt; <span class="number">0x3711a3be128c</span> @  <span class="number">118</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be128f</span> @  <span class="number">121</span> : <span class="number">50</span> <span class="number">18</span>             <span class="title class_">Inc</span> [<span class="number">24</span>]</span><br><span class="line">  <span class="number">365</span> E&gt; <span class="number">0x3711a3be1291</span> @  <span class="number">123</span> : <span class="number">23</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">StaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">  <span class="number">347</span> E&gt; <span class="number">0x3711a3be1294</span> @  <span class="number">126</span> : <span class="number">88</span> 3a <span class="number">00</span>          <span class="title class_">JumpLoop</span> [<span class="number">58</span>], [<span class="number">0</span>] (<span class="number">0x3711a3be125a</span> @ <span class="number">68</span>)</span><br><span class="line">  <span class="number">531</span> S&gt; <span class="number">0x3711a3be1297</span> @  <span class="number">129</span> : <span class="number">00</span> 0d 9f <span class="number">00</span>       <span class="title class_">LdaSmi</span>.<span class="property">Wide</span> [<span class="number">159</span>]</span><br><span class="line">  <span class="number">540</span> E&gt; <span class="number">0x3711a3be129b</span> @  <span class="number">133</span> : 6a f9 <span class="number">19</span>          <span class="title class_">TestEqual</span> r1, [<span class="number">25</span>]</span><br><span class="line">         <span class="number">0x3711a3be129e</span> @  <span class="number">136</span> : <span class="number">98</span> <span class="number">32</span>             <span class="title class_">JumpIfFalse</span> [<span class="number">50</span>] (<span class="number">0x3711a3be12d0</span> @ <span class="number">186</span>)</span><br><span class="line">  <span class="number">563</span> S&gt; <span class="number">0x3711a3be12a0</span> @  <span class="number">138</span> : 0c                <span class="title class_">LdaZero</span> </span><br><span class="line">  <span class="number">564</span> E&gt; <span class="number">0x3711a3be12a1</span> @  <span class="number">139</span> : <span class="number">23</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">StaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">  <span class="number">569</span> S&gt; <span class="number">0x3711a3be12a4</span> @  <span class="number">142</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be12a7</span> @  <span class="number">145</span> : c1                <span class="title class_">Star2</span> </span><br><span class="line">         <span class="number">0x3711a3be12a8</span> @  <span class="number">146</span> : 0d 2b             <span class="title class_">LdaSmi</span> [<span class="number">43</span>]</span><br><span class="line">  <span class="number">569</span> E&gt; <span class="number">0x3711a3be12aa</span> @  <span class="number">148</span> : 6c f8 1a          <span class="title class_">TestLessThan</span> r2, [<span class="number">26</span>]</span><br><span class="line">         <span class="number">0x3711a3be12ad</span> @  <span class="number">151</span> : <span class="number">98</span> <span class="number">21</span>             <span class="title class_">JumpIfFalse</span> [<span class="number">33</span>] (<span class="number">0x3711a3be12ce</span> @ <span class="number">184</span>)</span><br><span class="line">  <span class="number">604</span> S&gt; <span class="number">0x3711a3be12af</span> @  <span class="number">153</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">  <span class="number">603</span> E&gt; <span class="number">0x3711a3be12b2</span> @  <span class="number">156</span> : 2f <span class="number">05</span> 1b          <span class="title class_">LdaKeyedProperty</span> a2, [<span class="number">27</span>]</span><br><span class="line">         <span class="number">0x3711a3be12b5</span> @  <span class="number">159</span> : c1                <span class="title class_">Star2</span> </span><br><span class="line">  <span class="number">614</span> E&gt; <span class="number">0x3711a3be12b6</span> @  <span class="number">160</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">  <span class="number">613</span> E&gt; <span class="number">0x3711a3be12b9</span> @  <span class="number">163</span> : 2f <span class="number">04</span> 1d          <span class="title class_">LdaKeyedProperty</span> a1, [<span class="number">29</span>]</span><br><span class="line">  <span class="number">607</span> E&gt; <span class="number">0x3711a3be12bc</span> @  <span class="number">166</span> : 6a f8 1f          <span class="title class_">TestEqual</span> r2, [<span class="number">31</span>]</span><br><span class="line">         <span class="number">0x3711a3be12bf</span> @  <span class="number">169</span> : <span class="number">97</span> <span class="number">04</span>             <span class="title class_">JumpIfTrue</span> [<span class="number">4</span>] (<span class="number">0x3711a3be12c3</span> @ <span class="number">173</span>)</span><br><span class="line">  <span class="number">636</span> S&gt; <span class="number">0x3711a3be12c1</span> @  <span class="number">171</span> : <span class="number">12</span>                <span class="title class_">LdaFalse</span> </span><br><span class="line">  <span class="number">649</span> S&gt; <span class="number">0x3711a3be12c2</span> @  <span class="number">172</span> : a8                <span class="title class_">Return</span> </span><br><span class="line">  <span class="number">575</span> S&gt; <span class="number">0x3711a3be12c3</span> @  <span class="number">173</span> : <span class="number">21</span> <span class="number">00</span> <span class="number">02</span>          <span class="title class_">LdaGlobal</span> [<span class="number">0</span>], [<span class="number">2</span>]</span><br><span class="line">         <span class="number">0x3711a3be12c6</span> @  <span class="number">176</span> : <span class="number">50</span> <span class="number">20</span>             <span class="title class_">Inc</span> [<span class="number">32</span>]</span><br><span class="line">  <span class="number">575</span> E&gt; <span class="number">0x3711a3be12c8</span> @  <span class="number">178</span> : <span class="number">23</span> <span class="number">00</span> <span class="number">00</span>          <span class="title class_">StaGlobal</span> [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">  <span class="number">558</span> E&gt; <span class="number">0x3711a3be12cb</span> @  <span class="number">181</span> : <span class="number">88</span> <span class="number">27</span> <span class="number">00</span>          <span class="title class_">JumpLoop</span> [<span class="number">39</span>], [<span class="number">0</span>] (<span class="number">0x3711a3be12a4</span> @ <span class="number">142</span>)</span><br><span class="line">  <span class="number">682</span> S&gt; <span class="number">0x3711a3be12ce</span> @  <span class="number">184</span> : <span class="number">11</span>                <span class="title class_">LdaTrue</span> </span><br><span class="line">  <span class="number">694</span> S&gt; <span class="number">0x3711a3be12cf</span> @  <span class="number">185</span> : a8                <span class="title class_">Return</span> </span><br><span class="line">  <span class="number">705</span> S&gt; <span class="number">0x3711a3be12d0</span> @  <span class="number">186</span> : <span class="number">12</span>                <span class="title class_">LdaFalse</span> </span><br><span class="line">  <span class="number">718</span> S&gt; <span class="number">0x3711a3be12d1</span> @  <span class="number">187</span> : a8                <span class="title class_">Return</span> </span><br><span class="line"><span class="title class_">Constant</span> pool (size = <span class="number">1</span>)</span><br><span class="line"><span class="number">0x3711a3be11c9</span>: [<span class="title class_">FixedArray</span>] <span class="keyword">in</span> <span class="title class_">OldSpace</span></span><br><span class="line"> - <span class="attr">map</span>: <span class="number">0x2546cb1c12c1</span> &lt;<span class="title class_">Map</span>&gt;</span><br><span class="line"> - <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">           <span class="number">0</span>: <span class="number">0x2546cb1c9159</span> &lt;<span class="title class_">String</span>[<span class="number">1</span>]: #i&gt;</span><br><span class="line"><span class="title class_">Handler</span> <span class="title class_">Table</span> (size = <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Source</span> <span class="title class_">Position</span> <span class="title class_">Table</span> (size = <span class="number">119</span>)</span><br><span class="line"><span class="number">0x3711a3be12d9</span> &lt;<span class="title class_">ByteArray</span>[<span class="number">119</span>]&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">LdaSmi.Wide [170]</span><br><span class="line">Star0 //r0=170 </span><br><span class="line">LdaZero //acc=0</span><br><span class="line">StaGlobal [0], [0]</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">Star2 //r2=i</span><br><span class="line">LdaSmi [19]//acc=19</span><br><span class="line">TestLessThan r2, [4] // if i &lt;19</span><br><span class="line">JumpIfFalse [42] (0x3711a3be1252 @ 60) // 如果返回False 就跳到60</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">LdaKeyedProperty a0,[6] //acc=a0[i]</span><br><span class="line">Add r0, [8]//acc+=r0</span><br><span class="line">AddSmi [51], [9] //acc+=51</span><br><span class="line">BitwiseAndSmi.Wide [255], [5] //acc&amp;=0xff</span><br><span class="line">Star0 //r0=acc</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">Star3  //r3=i</span><br><span class="line">Ldar r0 //acc=r0</span><br><span class="line">StaKeyedProperty a1, r3, [10] //这个就类似于python里面的键值对 a1[a3]=acc （即a1[i]=acc）</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">Inc [12]//i+=1</span><br><span class="line">StaGlobal [0], [0]</span><br><span class="line">JumpLoop [48], [0] (0x3711a3be121f @ 9)//到这里形成第一个循环体</span><br><span class="line">经过19次加密之后开始新的循环体</span><br><span class="line">LdaSmi [85]</span><br><span class="line">Star1//r1=85 </span><br><span class="line">LdaSmi [19]</span><br><span class="line">StaGlobal [0], [0] //i=19</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">Star2 //r2=i</span><br><span class="line">LdaSmi [43]</span><br><span class="line">estLessThan r2, [13]</span><br><span class="line">JumpIfFalse [52] (0x3711a3be1297 @ 129)//if i&lt;43 如果返回False jmp 129</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">Star3  //r3=i</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">LdaKeyedProperty a0, [16] //acc=a0[i]</span><br><span class="line">Add r1, [15]// acc+=r1</span><br><span class="line">BitwiseAndSmi.Wide [255], [14] //acc&amp;=0xff</span><br><span class="line">StaKeyedProperty a1, r3, [18] //a1[r3]=acc</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">LdaKeyedProperty a1, [22] //acc=a1[i]</span><br><span class="line">BitwiseXor r1, [21] //acc^=r1</span><br><span class="line">BitwiseAndSmi.Wide [255], [20] // acc &amp;= 0xff</span><br><span class="line">Star1  //r1=acc</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">Inc [24] //i+=1</span><br><span class="line">StaGlobal [0], [0]</span><br><span class="line">JumpLoop [58], [0] (0x3711a3be125a @ 68) //到这里第二个循环体结束</span><br><span class="line">LdaSmi.Wide [159]</span><br><span class="line">TestEqual r1, [25]</span><br><span class="line">JumpIfFalse [50] (0x3711a3be12d0 @ 186)// if i&lt;159 </span><br><span class="line">LdaZero  //acc=0</span><br><span class="line">StaGlobal [0], [0]</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">Star2 //r2=i</span><br><span class="line">LdaSmi [43]</span><br><span class="line">TestLessThan r2, [26]</span><br><span class="line">JumpIfFalse [33] (0x3711a3be12ce @ 184) // if r2&gt;43  return False</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">LdaKeyedProperty a2, [27]</span><br><span class="line">Star2 //r2=a2[i]</span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">LdaKeyedProperty a1, [29]</span><br><span class="line">TestEqual r2, [31] //if(a1[i]==a2[i])  不相等 return False</span><br><span class="line">JumpIfTrue [4] (0x3711a3be12c3 @ 173)</span><br><span class="line">LdaFalse </span><br><span class="line">Return </span><br><span class="line">LdaGlobal [0], [2]</span><br><span class="line">Inc [32] //i+=1</span><br><span class="line">StaGlobal [0], [0]</span><br><span class="line">JumpLoop [39], [0] (0x3711a3be12a4 @ 142) //结束循环</span><br></pre></td></tr></table></figure><h3 id="加密函数-实现"><a href="#加密函数-实现" class="headerlink" title="加密函数-实现"></a>加密函数-实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">end=<span class="string">&#x27;3edd7925cd6e04ab44f25bef57bc53bd20b74b8c11f893090fdcdfddad0709100100fe6a9230333234fbae&#x27;</span></span><br><span class="line">r0 = <span class="number">170</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">43</span>): </span><br><span class="line">    dst=<span class="built_in">int</span>(end[<span class="number">2</span>*i:<span class="number">2</span>*i+<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">    <span class="built_in">input</span>[i]+=r0</span><br><span class="line">    <span class="built_in">input</span>[i]+=<span class="number">51</span></span><br><span class="line">    <span class="built_in">input</span>[i]&amp;=<span class="number">0xff</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">input</span>[i] == dst:</span><br><span class="line">        r0=<span class="built_in">input</span>[i]</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">r1 = <span class="number">85</span>        </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>,<span class="number">43</span>):</span><br><span class="line">    dst=<span class="built_in">int</span>(end[<span class="number">2</span>*i:<span class="number">2</span>*i+<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">    <span class="built_in">input</span>[i]+=r1</span><br><span class="line">    <span class="built_in">input</span>[i]&amp;=<span class="number">0xff</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">input</span>[i] == dst:</span><br><span class="line">        r1=(<span class="built_in">input</span>[i]^r1)&amp;<span class="number">0xff</span></span><br><span class="line">        <span class="keyword">break</span>  </span><br></pre></td></tr></table></figure><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">end=<span class="string">&#x27;3edd7925cd6e04ab44f25bef57bc53bd20b74b8c11f893090fdcdfddad0709100100fe6a9230333234fbae&#x27;</span></span><br><span class="line">r0 = <span class="number">170</span></span><br><span class="line">r1 = <span class="number">85</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">19</span>): </span><br><span class="line">    dst=<span class="built_in">int</span>(end[<span class="number">2</span>*i:<span class="number">2</span>*i+<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">     acc =ch</span><br><span class="line">     acc+=r0</span><br><span class="line">     acc+=<span class="number">51</span></span><br><span class="line">     acc&amp;=<span class="number">0xff</span></span><br><span class="line">     <span class="keyword">if</span> acc == dst:</span><br><span class="line">        flag+=<span class="built_in">chr</span>(ch)</span><br><span class="line">        r0=acc</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">r1=<span class="number">85</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>,<span class="number">43</span>): </span><br><span class="line">    dst=<span class="built_in">int</span>(end[<span class="number">2</span>*i:<span class="number">2</span>*i+<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">     acc =ch</span><br><span class="line">     acc+=r1</span><br><span class="line">     acc&amp;=<span class="number">0xff</span></span><br><span class="line">     <span class="keyword">if</span> acc == dst:</span><br><span class="line">        flag+=<span class="built_in">chr</span>(ch)</span><br><span class="line">        r1=(acc^r1)&amp;<span class="number">0xff</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(flag)     </span><br><span class="line"><span class="comment">#得到FLAG:aliyunctf&#123;6a52d70da780cfe7f7218897535a4f61&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;复现本题主要是为了学习js字节码，若有不足之处，请各位师傅多多指出&lt;/p&gt;
&lt;p&gt;V8 是 Google 开发的开源 JavaScript 引擎。 Chrome、Node.js和许多其他应用程序都在使用 V8。&lt;br&gt;如果只发布V8引擎编译后的字节码，就可以保护源码。&lt;/p</summary>
      
    
    
    
    <category term="js字节码" scheme="https://5m10v3.github.io/categories/js%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
    
    <category term="字节码" scheme="https://5m10v3.github.io/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Windows内核驱动学习(八)</title>
    <link href="https://5m10v3.github.io/2024/04/14/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%85%AB)/"/>
    <id>https://5m10v3.github.io/2024/04/14/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%85%AB)/</id>
    <published>2024-04-13T16:00:00.000Z</published>
    <updated>2024-04-20T01:07:13.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单通信"><a href="#简单通信" class="headerlink" title="简单通信"></a>简单通信</h2><p>这篇文章主要实现内核驱动和应用层之间的通信，通信是驱动开发中不可或缺的一部分，通过通信可以实现驱动和应用层之间的数据交换和控制命令传递等功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line">NTSTATUS <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//删除符号链接</span></span><br><span class="line">UNICODE_STRING uLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;uLinkName, LINK_NAME);</span><br><span class="line">IoDeleteSymbolicLink(&amp;uLinkName);</span><br><span class="line">IoDeleteDevice(pDriverObject-&gt;DeviceObject);</span><br><span class="line">    DbgPrintEx(<span class="number">77</span>,<span class="number">0</span>,<span class="string">&quot;Unload success!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject,PUNICODE_STRING pReg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pDriverObject-&gt;DriverUnload=DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是一个驱动程序最基本的框架,接下来我们要逐步创建IO通信</p><p>我们要先定义我们的驱动名称和符号链接名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">L&quot;\\device\\My_Driver&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINK_NAME <span class="string">L&quot;\\dosDevices\\My_Device&quot;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//定义驱动名称和符号链接名称</span><br><span class="line">UNICODE_STRING usDriverName=&#123;0&#125;;</span><br><span class="line">UNICODE_STRING usLinkName=&#123;0&#125;;</span><br><span class="line">//定义一个状态</span><br><span class="line">NTSTATUS ntStatus=0;</span><br><span class="line">//定义设备名称</span><br><span class="line">PDEVICE_OBJECT pDeviceObject =NULL;</span><br><span class="line">//初始化字符串</span><br><span class="line">RtlInitUnicodeString(&amp;usDriverName,DEVICE_NAME);</span><br><span class="line">RtlInitUnicodeString(&amp;usLinkName,LINK_NAME);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*IoCreateDevice(</span><br><span class="line">    _In_  PDRIVER_OBJECT DriverObject, //驱动对象</span><br><span class="line">    _In_  ULONG DeviceExtensionSize,//默认0</span><br><span class="line">    _In_opt_ PUNICODE_STRING DeviceName,  //驱动的名称</span><br><span class="line">    _In_  DEVICE_TYPE DeviceType,//填FILE_DEVICE_UNKNOWN</span><br><span class="line">    _In_  ULONG DeviceCharacteristics, //填0</span><br><span class="line">    _In_  BOOLEAN Exclusive,//填True</span><br><span class="line">    PDEVICE_OBJECT *DeviceObject //设备对象</span><br><span class="line">    );*/</span><br><span class="line">//创建设备对象</span><br><span class="line">ntStatus=IoCreateDevice(pDriverObject,0,&amp;usDriverName,FILE_DEVICE_UNKNOWN,0,TRUE,&amp;pDeviceObject);</span><br><span class="line">if(!NT_SUCCESS(ntStatus))</span><br><span class="line">&#123;</span><br><span class="line">  DbgPrintEx(77,0,&quot;IoCreateDevice Failed:%wZ\r\n&quot;);</span><br><span class="line">  return ntStatus;</span><br><span class="line">&#125;</span><br><span class="line">//设置通讯模式</span><br><span class="line">pDeviceObject-&gt;Flags |= DO_BUFFERED_IO ;//这种模式是基于缓冲区的</span><br><span class="line">//创建符号链接</span><br><span class="line">ntStatus = IoCreateSymbolicLink(&amp;usLinkName,&amp;usDriverName)</span><br><span class="line">/*</span><br><span class="line">#define DO_VERIFY_VOLUME                    0x00000002      </span><br><span class="line">#define DO_BUFFERED_IO                      0x00000004      </span><br><span class="line">#define DO_EXCLUSIVE                        0x00000008      </span><br><span class="line">#define DO_DIRECT_IO                        0x00000010      </span><br><span class="line">#define DO_MAP_IO_BUFFER                    0x00000020      </span><br><span class="line">#define DO_DEVICE_HAS_NAME                  0x00000040      </span><br><span class="line">#define DO_DEVICE_INITIALIZING              0x00000080      </span><br><span class="line">#define DO_SYSTEM_BOOT_PARTITION            0x00000100      </span><br><span class="line">#define DO_LONG_TERM_REQUESTS               0x00000200      </span><br><span class="line">#define DO_NEVER_LAST_DEVICE                0x00000400      </span><br><span class="line">#define DO_SHUTDOWN_REGISTERED              0x00000800      </span><br><span class="line">#define DO_BUS_ENUMERATED_DEVICE            0x00001000      </span><br><span class="line">#define DO_POWER_PAGABLE                    0x00002000      </span><br><span class="line">#define DO_POWER_INRUSH                     0x00004000      </span><br><span class="line">#define DO_LOW_PRIORITY_FILESYSTEM          0x00010000      </span><br><span class="line">#define DO_SUPPORTS_PERSISTENT_ACLS         0x00020000      </span><br><span class="line">#define DO_SUPPORTS_TRANSACTIONS            0x00040000      </span><br><span class="line">#define DO_FORCE_NEITHER_IO                 0x00080000      </span><br><span class="line">#define DO_VOLUME_DEVICE_OBJECT             0x00100000        </span><br><span class="line">#define DO_SYSTEM_SYSTEM_PARTITION          0x00200000      </span><br><span class="line">#define DO_SYSTEM_CRITICAL_PARTITION        0x00400000      </span><br><span class="line">#define DO_DISALLOW_EXECUTE                 0x00800000      </span><br><span class="line">#define DO_DEVICE_TO_BE_RESET               0x04000000      </span><br><span class="line">#define DO_DEVICE_IRP_REQUIRES_EXTENSION    0x08000000      </span><br><span class="line">#define DO_DAX_VOLUME                       0x10000000      </span><br><span class="line">#define DO_BOOT_CRITICAL                    0x20000000  </span><br><span class="line">*/    </span><br></pre></td></tr></table></figure><p>派遣函数是驱动程序中用来处理<code>I/O</code>请求的核心函数，一般情况下，驱动程序通过实现一组派遣函数来处理<code>I/O</code>请求。这些派遣函数包括：</p><ul><li>IRP_MJ_CREATE：用于处理创建请求。</li><li>IRP_MJ_READ：用于处理读请求。</li><li>IRP_MJ_WRITE：用于处理写请求。</li><li>IRP_MJ_DEVICE_CONTROL：用于处理设备控制请求等。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE]=DispatchCreate;</span><br><span class="line">pDriverObject-&gt;MajorFunction[IRP_MJ_READ]=DispatchRead;</span><br><span class="line">pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE]=DispatchWrite;</span><br><span class="line">pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL]=DispatchIoctrl;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS  <span class="title function_">DispatchCommon</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ <span class="keyword">struct</span> _DEVICE_OBJECT* DeviceObject,</span></span><br><span class="line"><span class="params">_Inout_ <span class="keyword">struct</span> _IRP* Irp</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置Irp处理成功</span></span><br><span class="line">    Irp-&gt;IoStatus.Status =STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">//设置返回信息</span></span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//结束IRP处理流程</span></span><br><span class="line">    IoCompleteRequest(Irp,IO_NO_INCREMENT);</span><br><span class="line">    <span class="comment">//返回成功</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是一个基本功能的派遣函数，而read ，write ，IoControl就是添加了不同的功能。</p><h3 id="IRP-MJ-READ"><a href="#IRP-MJ-READ" class="headerlink" title="IRP_MJ_READ"></a>IRP_MJ_READ</h3><h4 id="R0层"><a href="#R0层" class="headerlink" title="R0层"></a>R0层</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS  <span class="title function_">DispatchRead</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ <span class="keyword">struct</span> _DEVICE_OBJECT* DeviceObject,</span></span><br><span class="line"><span class="params">_Inout_ <span class="keyword">struct</span> _IRP* Irp</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取当前Irp栈</span></span><br><span class="line">    PIO_STACK_LOCATION pStack =IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="comment">//拿到r3缓冲区</span></span><br><span class="line">    PVOID pReadBuffer = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="comment">//获得读取长度</span></span><br><span class="line">    ULONG ulReadLength =pStack-&gt;Parameters.Read.Length;</span><br><span class="line">    <span class="comment">//计算返回数据的长度</span></span><br><span class="line">    ULONG ulStrLen =(wcslen(<span class="string">L&quot;Hello world funck!&quot;</span>)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">    <span class="comment">//最小数据长度</span></span><br><span class="line">    ULONG uMin = ulReadLength&gt;ulStrLen ?ulStrLen:ulReadLength;</span><br><span class="line">    RtlCopyMemory(pReadBuffer,<span class="string">L&quot;Hello world funck!&quot;</span>,uMin)</span><br><span class="line">    <span class="comment">//设置Irp处理成功</span></span><br><span class="line">    Irp-&gt;IoStatus.Status =STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">//设置返回信息</span></span><br><span class="line">    Irp-&gt;IoStatus.Information = uMin; <span class="comment">//这里要设置返回值为uMin</span></span><br><span class="line">    <span class="comment">//结束IRP处理流程</span></span><br><span class="line">    IoCompleteRequest(Irp,IO_NO_INCREMENT);</span><br><span class="line">    <span class="comment">//返回成功</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="R3层"><a href="#R3层" class="headerlink" title="R3层"></a>R3层</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_LINKE_NAME <span class="string">L&quot;\\\\.\\My_Device&quot;</span>  <span class="comment">//这里要跟你设置的符号链接的名称一样</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建句柄</span></span><br><span class="line">    HANDLE  hFile = <span class="built_in">CreateFile</span>(DEVICE_LINKE_NAME, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFile Failed%x\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UCHAR Buffer[MAX_PATH];</span><br><span class="line">    ULONG dwRet;</span><br><span class="line">    BOOL bRET =<span class="built_in">ReadFile</span>(hFile,Buffer,MAX_PATH,&amp;dwRet,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(bRET)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;read %d bytes\r\n&quot;</span>, dwRet);</span><br><span class="line">       <span class="built_in">wprintf</span>(<span class="string">L&quot;%s\r\n&quot;</span>, Buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IRP-MJ-WRITE"><a href="#IRP-MJ-WRITE" class="headerlink" title="IRP_MJ_WRITE"></a>IRP_MJ_WRITE</h3><h4 id="R0层-1"><a href="#R0层-1" class="headerlink" title="R0层"></a>R0层</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS  <span class="title function_">DispatchWrite</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ <span class="keyword">struct</span> _DEVICE_OBJECT* DeviceObject,</span></span><br><span class="line"><span class="params">_Inout_ <span class="keyword">struct</span> _IRP* Irp</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取当前Irp栈</span></span><br><span class="line">    PIO_STACK_LOCATION pStack =IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="comment">//拿到r3缓冲区</span></span><br><span class="line">    PVOID pWriteBuffer = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="comment">//获得读取长度</span></span><br><span class="line">    ULONG ulWriteLength =pStack-&gt;Parameters.Read.Length;</span><br><span class="line">    UNICODE_STRING usStr=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    RtlInitUnicodeString(&amp;usStr,pWriteBuffer);</span><br><span class="line">    DbgPrint(<span class="string">&quot;%wZ\r\n&quot;</span>, usStr);</span><br><span class="line">DbgPrint(<span class="string">&quot;write success!!!&quot;</span>);</span><br><span class="line">    <span class="comment">//设置Irp处理成功</span></span><br><span class="line">    Irp-&gt;IoStatus.Status =STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">//设置返回信息</span></span><br><span class="line">    Irp-&gt;IoStatus.Information = ulWriteLength; <span class="comment">//这里要设置返回值为uMin</span></span><br><span class="line">    <span class="comment">//结束IRP处理流程</span></span><br><span class="line">    IoCompleteRequest(Irp,IO_NO_INCREMENT);</span><br><span class="line">    <span class="comment">//返回成功</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="R3层-1"><a href="#R3层-1" class="headerlink" title="R3层"></a>R3层</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_LINKE_NAME <span class="string">L&quot;\\\\.\\My_Device&quot;</span>  <span class="comment">//这里要跟你设置的符号链接的名称一样</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建句柄</span></span><br><span class="line">    HANDLE  hFile = <span class="built_in">CreateFile</span>(DEVICE_LINKE_NAME, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFile Failed%x\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ULONG dwRet; </span><br><span class="line">    DWORD dwWriteLen = (<span class="built_in">wcslen</span>(<span class="string">L&quot;Hello World Fuck!&quot;</span>))*<span class="built_in">sizeof</span>(WCHAR) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">WriteFile</span>(hFile, <span class="string">L&quot;Hello World Fuck!&quot;</span>,dwWriteLen,&amp;dwRet,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, dwRet);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO通信"><a href="#IO通信" class="headerlink" title="IO通信"></a>IO通信</h2><h3 id="IRP-MJ-DEVICE-CONTROL"><a href="#IRP-MJ-DEVICE-CONTROL" class="headerlink" title="IRP_MJ_DEVICE_CONTROL"></a>IRP_MJ_DEVICE_CONTROL</h3><p>进行IO通信重要的是控制码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define IRP_IOCTRL_BASE 0x8000</span><br><span class="line">#define IRP_IOCTRL_CODE(i) CTL_CODE(FILE_DEVICE_UNKNOWN,IRP_IOCTRL_BASE + i,METHOD_BUFFERED,FILE_ANY_ACCESS)</span><br><span class="line">#define GET_PROCESS IRP_IOCTRL_CODE(0)</span><br></pre></td></tr></table></figure><h4 id="R0层-2"><a href="#R0层-2" class="headerlink" title="R0层"></a>R0层</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS  <span class="title function_">DispatchIoCtrl</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ <span class="keyword">struct</span> _DEVICE_OBJECT* DeviceObject,</span></span><br><span class="line"><span class="params">_Inout_ <span class="keyword">struct</span> _IRP* Irp</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line"><span class="comment">//获得控制码</span></span><br><span class="line">ULONG code = pStack-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line"><span class="comment">//输入输出缓冲区</span></span><br><span class="line">PVOID pReadBuffer = <span class="literal">NULL</span>;</span><br><span class="line">ULONG uReadLength = <span class="number">0</span>;</span><br><span class="line">PVOID pWriteBuffer = <span class="literal">NULL</span>;</span><br><span class="line">ULONG uWriteLength = <span class="number">0</span>;</span><br><span class="line">pReadBuffer = pWriteBuffer = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">uReadLength = uWriteLength = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line"><span class="keyword">switch</span> (code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> GET_PROCESS:</span><br><span class="line">DbgPrint(<span class="string">&quot;%s\r\n&quot;</span>, pReadBuffer);</span><br><span class="line">RtlZeroMemory(pWriteBuffer, <span class="number">1024</span>);</span><br><span class="line">ULONG uRetLen = <span class="built_in">strlen</span>(<span class="string">&quot;DispathchCrtl ok\r\n&quot;</span>);</span><br><span class="line">RtlCopyMemory(pWriteBuffer, <span class="string">&quot;DispathchCrtl ok\r\n&quot;</span>, uRetLen);</span><br><span class="line">Irp-&gt;IoStatus.Information = uRetLen;</span><br><span class="line">Irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">IoCompleteRequest(Irp, IO_NO_INCREMENT);<span class="comment">//结束IRP </span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置Irp处理成功</span></span><br><span class="line">Irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line"><span class="comment">//设置返回信息</span></span><br><span class="line">Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//结束IRP处理流程</span></span><br><span class="line">IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line"><span class="comment">//返回成功</span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="R3层-2"><a href="#R3层-2" class="headerlink" title="R3层"></a>R3层</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_LINKE_NAME <span class="string">L&quot;\\\\.\\My_Device&quot;</span>  <span class="comment">//这里要跟你设置的符号链接的名称一样</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_IOCTRL_BASE 0x8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_IOCTRL_CODE(i) CTL_CODE(FILE_DEVICE_UNKNOWN,IRP_IOCTRL_BASE + i,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PROCESS IRP_IOCTRL_CODE(0)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hFile=<span class="built_in">CreateFile</span>(DEVICE_LINKE_NAME, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFile Failed%x\r\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">char</span> ReadBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">       <span class="type">char</span> WriteBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">       DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;输入字符串\r\n&quot;</span>);</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;ReadBuf);</span><br><span class="line">       <span class="built_in">DeviceIoControl</span>(hFile, GET_PROCESS, ReadBuf,<span class="built_in">sizeof</span>(ReadBuf), WriteBuf,<span class="built_in">sizeof</span>(WriteBuf),&amp;dwRet,<span class="number">0</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d %s\r\n&quot;</span>, dwRet, WriteBuf);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单通信&quot;&gt;&lt;a href=&quot;#简单通信&quot; class=&quot;headerlink&quot; title=&quot;简单通信&quot;&gt;&lt;/a&gt;简单通信&lt;/h2&gt;&lt;p&gt;这篇文章主要实现内核驱动和应用层之间的通信，通信是驱动开发中不可或缺的一部分，通过通信可以实现驱动和应用层之间的数据交换和控</summary>
      
    
    
    
    <category term="内核驱动" scheme="https://5m10v3.github.io/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="Windows内核驱动开发" scheme="https://5m10v3.github.io/tags/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows内核驱动学习(七)</title>
    <link href="https://5m10v3.github.io/2024/04/13/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%B8%83)/"/>
    <id>https://5m10v3.github.io/2024/04/13/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%B8%83)/</id>
    <published>2024-04-12T16:00:00.000Z</published>
    <updated>2024-04-16T13:05:17.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="蓝屏分析"><a href="#蓝屏分析" class="headerlink" title="蓝屏分析"></a>蓝屏分析</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;蓝屏分析&quot;&gt;&lt;a href=&quot;#蓝屏分析&quot; class=&quot;headerlink&quot; title=&quot;蓝屏分析&quot;&gt;&lt;/a&gt;蓝屏分析&lt;/h2&gt;</summary>
      
    
    
    
    <category term="内核驱动" scheme="https://5m10v3.github.io/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="Windows内核驱动开发" scheme="https://5m10v3.github.io/tags/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows内核驱动学习(六)</title>
    <link href="https://5m10v3.github.io/2024/04/12/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
    <id>https://5m10v3.github.io/2024/04/12/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%85%AD)/</id>
    <published>2024-04-11T16:00:00.000Z</published>
    <updated>2024-04-13T05:17:29.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="驱动断链"><a href="#驱动断链" class="headerlink" title="驱动断链"></a>驱动断链</h2><p>本文参考<a href="https://www.cnblogs.com/LyShark/p/11652019.html">驱动开发：DKOM 实现进程隐藏</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;驱动断链&quot;&gt;&lt;a href=&quot;#驱动断链&quot; class=&quot;headerlink&quot; title=&quot;驱动断链&quot;&gt;&lt;/a&gt;驱动断链&lt;/h2&gt;&lt;p&gt;本文参考&lt;a href=&quot;https://www.cnblogs.com/LyShark/p/11652019.html&quot;&gt;</summary>
      
    
    
    
    <category term="内核驱动" scheme="https://5m10v3.github.io/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="Windows内核驱动开发" scheme="https://5m10v3.github.io/tags/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows内核驱动学习(五)</title>
    <link href="https://5m10v3.github.io/2024/04/11/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
    <id>https://5m10v3.github.io/2024/04/11/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/</id>
    <published>2024-04-10T16:00:00.000Z</published>
    <updated>2024-04-13T05:17:03.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>基本数据类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> 重定义为 ULONG。 </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> 重定义为 UCHAR。 </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> 重定义为 UINT。 </span><br><span class="line"><span class="type">void</span> 重定义为 VOID。 </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *重定义为 PULONG。 </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * 重定义为 PUCHAR。 </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *重定义 PUINT。 </span><br><span class="line"><span class="type">void</span> *重定义为 PVOID。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">UnDriver</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(<span class="string">&quot;驱动卸载成功 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义内核字符串</span></span><br><span class="line">ANSI_STRING ansi;</span><br><span class="line">UNICODE_STRING unicode;</span><br><span class="line">UNICODE_STRING str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义普通字符串</span></span><br><span class="line"><span class="type">char</span> * char_string = <span class="string">&quot;hello lyshark&quot;</span>;</span><br><span class="line"><span class="type">wchar_t</span> *wchar_string = (WCHAR*)<span class="string">&quot;hello lyshark&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化字符串的多种方式</span></span><br><span class="line">RtlInitAnsiString(&amp;ansi, char_string);</span><br><span class="line">RtlInitUnicodeString(&amp;unicode, wchar_string);</span><br><span class="line">RtlInitUnicodeString(&amp;str, <span class="string">L&quot;hello lyshark&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变原始字符串（乱码位置，此处仅用于演示赋值方式）</span></span><br><span class="line">char_string[<span class="number">0</span>] = (CHAR)<span class="string">&quot;A&quot;</span>;         <span class="comment">// char类型每个占用1字节</span></span><br><span class="line">char_string[<span class="number">1</span>] = (CHAR)<span class="string">&quot;B&quot;</span>;</span><br><span class="line"></span><br><span class="line">wchar_string[<span class="number">0</span>] = (WCHAR)<span class="string">&quot;A&quot;</span>;        <span class="comment">// wchar类型每个占用2字节</span></span><br><span class="line">wchar_string[<span class="number">2</span>] = (WCHAR)<span class="string">&quot;B&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出字符串 %Z</span></span><br><span class="line">DbgPrint(<span class="string">&quot;输出ANSI: %Z \n&quot;</span>, &amp;ansi);</span><br><span class="line">DbgPrint(<span class="string">&quot;输出WCHAR: %Z \n&quot;</span>, &amp;unicode);</span><br><span class="line">DbgPrint(<span class="string">&quot;输出字符串: %wZ \n&quot;</span>, &amp;str);</span><br><span class="line"></span><br><span class="line">DbgPrint(<span class="string">&quot;驱动加载成功 \n&quot;</span>);</span><br><span class="line">Driver-&gt;DriverUnload = UnDriver;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以在vs2019 中 查找 <strong>RtlInitAnsiString</strong>，<strong>RtlInitUnicodeString</strong>，<strong>RtlInitUnicodeString</strong>的定义</p><p><img src="/../image/624.png" class="lazyload" data-srcset="/../image/624.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="624"></p><p><img src="/../image/625.png" class="lazyload" data-srcset="/../image/625.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="625"></p><p>我们发现都是这样的形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RtlInitAnsiString(&amp;ansi, char_string);</span><br><span class="line">RtlInitUnicodeString(&amp;unicode, wchar_string);</span><br><span class="line">RtlInitUnicodeString(&amp;str, <span class="string">L&quot;hello lyshark&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>在<code>Windows</code>内核中，为了实现高效的数据结构操作，通常会使用链表和结构体相结合的方式进行数据存储和操作。内核提供了一个专门用于链表操作的数据结构<code>LIST_ENTRY</code>，可以用来描述一个链表中的每一个节点。</p><p>使用链表来存储结构体时，需要在结构体中嵌入一个<code>LIST_ENTRY</code>类型的成员变量，用来连接相邻的节点。通过一些列链表操作函数，如<code>InitializeListHead、InsertHeadList、InsertTailList、RemoveEntryList</code>等，可以对链表中的结构体进行插入、删除、遍历等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span>  <span class="title class_">_XXX</span></span><br><span class="line">&#123;</span><br><span class="line">LIST_ENTRY List;</span><br><span class="line">DWORD x;</span><br><span class="line">&#125;XXX,*PXXX;</span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;驱动卸载成功 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT Driver, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">XXX headList;</span><br><span class="line">XXX x1;</span><br><span class="line">XXX x2;</span><br><span class="line">headList.x = <span class="number">5</span>;</span><br><span class="line">x1.x = <span class="number">0x10</span>;</span><br><span class="line">x2.x = <span class="number">0x20</span>;</span><br><span class="line"><span class="built_in">InitializeListHead</span>(&amp;headList.List);<span class="comment">//直接调用API初始化链表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">InitializeListHead</span>(&amp;x1.List);</span><br><span class="line"><span class="built_in">InitializeListHead</span>(&amp;x2.List);</span><br><span class="line"><span class="comment">//InsertHeadList(&amp;headList.List, &amp;x1.List);//插入头表</span></span><br><span class="line"><span class="built_in">InsertTailList</span>(&amp;headList.List, &amp;x1.List);<span class="comment">//插入尾表</span></span><br><span class="line"><span class="built_in">InsertTailList</span>(&amp;headList.List, &amp;x2.List);<span class="comment">//插入尾表</span></span><br><span class="line"><span class="comment">/*RemoveEntryList(&amp;x1.List);</span></span><br><span class="line"><span class="comment">RemoveHeadList(&amp;x1.List);*/</span></span><br><span class="line">PLIST_ENTRY pTempNext = &amp;headList.List;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">PXXX temp = (PXXX)pTempNext;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;x == <span class="number">0x20</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrintEx</span>(<span class="number">77</span>, <span class="number">0</span>, <span class="string">&quot;find value =%x\r\n&quot;</span>, temp-&gt;x);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pTempNext = pTempNext-&gt;Flink;</span><br><span class="line">&#125; <span class="keyword">while</span> (pTempNext != &amp;headList.List);</span><br><span class="line">Driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/644.png" class="lazyload" data-srcset="/../image/644.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="644"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串操作&quot;&gt;&lt;a href=&quot;#字符串操作&quot; class=&quot;headerlink&quot; title=&quot;字符串操作&quot;&gt;&lt;/a&gt;字符串操作&lt;/h2&gt;&lt;p&gt;基本数据类型&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</summary>
      
    
    
    
    <category term="内核驱动" scheme="https://5m10v3.github.io/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="Windows内核驱动开发" scheme="https://5m10v3.github.io/tags/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>单向链表及其基本操作(C语言)</title>
    <link href="https://5m10v3.github.io/2024/04/11/[%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84]%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C(C%E8%AF%AD%E8%A8%80)/"/>
    <id>https://5m10v3.github.io/2024/04/11/[%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84]%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2024-04-10T16:00:00.000Z</published>
    <updated>2024-04-11T16:26:48.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h1><h2 id="什么是单向链表"><a href="#什么是单向链表" class="headerlink" title="什么是单向链表"></a>什么是单向链表</h2><p><strong>链表</strong>是一种物理储存单元上非连续、非顺序的储存结构。它由一系列结点（链表中每一个元素称为结点）组成，结点可动态生成。每个结点包括两个部分：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong>。</p><p>其实可以形象的认为，<strong>单向链表</strong>就好像一列火车。<br>链表的节点就好像火车的每一节车厢，而链表节点的数据域就对应车厢中存放的货物，链表节点的指针域充当连接各节车厢的锁链。</p><h2 id="为什么需要单向链表"><a href="#为什么需要单向链表" class="headerlink" title="为什么需要单向链表"></a>为什么需要单向链表</h2><p>我们知道如何用数组去存储数据。但是在实际应用的过程中，我们有时会出现一些不可避免的问题：</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>假如定义了并初始化一个数组 <em><strong>a[5] &#x3D; {1,2,3,4,5}</strong></em>, 此时要在加入新的元素，只能开辟一个更大的数组。</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>假如定义一个数组 <em><strong>a[100000]</strong></em>, 但是只存储了几个元素，会导致浪费空间。</p><p>而单向链表这样链式的动态存储的数据结构，恰恰解决了使用数组时若数组已满无法插入新的数据的问题，以及使用数组时可能浪费大量存储空间的问题。</p><h1 id="单向链表的创建"><a href="#单向链表的创建" class="headerlink" title="单向链表的创建"></a>单向链表的创建</h1><h2 id="单个链表节点的构成"><a href="#单个链表节点的构成" class="headerlink" title="单个链表节点的构成"></a>单个链表节点的构成</h2><p>首先看一下单向链表节点的结构体，我们把单个节点看作是一节车厢，数据域就好像车厢存储的货物，指针域就好像锁链。</p><p><img src="/../image/627.png" class="lazyload" data-srcset="/../image/627.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="627"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype; <span class="comment">//数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    Elemtype data; <span class="comment">//结构体数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">//结构体指针域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表的初始化创建"><a href="#链表的初始化创建" class="headerlink" title="链表的初始化创建"></a>链表的初始化创建</h2><p>链表一般需要一个头节点，这个头结点一般是不带数据的。可以看作是驱动火车前进的火车头。</p><p><img src="/../image/628.png" class="lazyload" data-srcset="/../image/628.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="628"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Linklist *<span class="title function_">Initial_linklist</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">//向系统申请</span></span><br><span class="line">    Linklist *head=(Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表初始数据插入"><a href="#链表初始数据插入" class="headerlink" title="链表初始数据插入"></a>链表初始数据插入</h2><p>单向链表的初始数据可以是任意个，此处采用的是尾插法，后面会具体解释这个方法。</p><p><img src="/../image/629.png" class="lazyload" data-srcset="/../image/629.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="629"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建初始链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Create_linklist</span><span class="params">(Linklist *head,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    Linklist *node,*end;  <span class="comment">//普通节点，尾节点</span></span><br><span class="line">    end = head ; <span class="comment">//当链表为空时，头尾指向同一个节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建链表输入 %d 个元素:&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;                <span class="comment">//n为插入普通节点的个数</span></span><br><span class="line">node = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;next);</span><br><span class="line">    end-&gt;next=node;  <span class="comment">//当前end的next指向了新节点node</span></span><br><span class="line">    end = node; <span class="comment">//end往后移，此时新的节点变成尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    end-&gt;next =<span class="literal">NULL</span>; <span class="comment">//end最后变成NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单向链表的基本操作"><a href="#单向链表的基本操作" class="headerlink" title="单向链表的基本操作"></a>单向链表的基本操作</h1><h2 id="头插法-插入单个数据"><a href="#头插法-插入单个数据" class="headerlink" title="头插法 插入单个数据"></a>头插法 插入单个数据</h2><h3 id="头插法图解"><a href="#头插法图解" class="headerlink" title="头插法图解"></a>头插法图解</h3><p><img src="/../image/630.png" class="lazyload" data-srcset="/../image/630.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="630"></p><p><img src="/../image/631.png" class="lazyload" data-srcset="/../image/631.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="631"></p><p><img src="/../image/632.png" class="lazyload" data-srcset="/../image/632.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="632"></p><p>头插法代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_front</span><span class="params">(Linklist *head,<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">  Linklist *node = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">  node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  node-&gt;data=data;</span><br><span class="line">  </span><br><span class="line">  node-&gt;next=head-&gt;next; <span class="comment">//新节点node的next指向当前head的next</span></span><br><span class="line">  head-&gt;next=node;  <span class="comment">//head的next重新指向新节点node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插法-插入单个数据"><a href="#尾插法-插入单个数据" class="headerlink" title="尾插法 插入单个数据"></a>尾插法 插入单个数据</h2><h3 id="尾插法图解"><a href="#尾插法图解" class="headerlink" title="尾插法图解"></a>尾插法图解</h3><p>个人理解，尾插法就是依次node往后递</p><p><img src="/../image/633.png" class="lazyload" data-srcset="/../image/633.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="633"></p><p>尾插法代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_back</span><span class="params">(Linklist *head,<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">   Linklist *node = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">  node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  node-&gt;data=data;</span><br><span class="line">    </span><br><span class="line">  Linklist *end =head; <span class="comment">//起初end指向头节点</span></span><br><span class="line">  <span class="keyword">while</span>(end-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      end=end-&gt;next;<span class="comment">//end指针往后移，直到最后一个节点</span></span><br><span class="line">      end-&gt;next=node; <span class="comment">//当前end的next指向了新节点node</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定位置插入节点"><a href="#指定位置插入节点" class="headerlink" title="指定位置插入节点"></a>指定位置插入节点</h2><h3 id="分析及解释"><a href="#分析及解释" class="headerlink" title="分析及解释"></a>分析及解释</h3><p>指定位置插入单个数据，这里一般设定为在第 <em><strong>k</strong></em> 个带数据的普通节点(除去头节点)位置插入一个新的节点。其实指定位置插入新节点的原理和头插法是类似的，只不过是将第 <em><strong>k</strong></em> 个带数据节点的前一个节点看成头结点一样。因此我们需要找到第 <em><strong>k-1</strong></em> 个带数据节点，假如遍历指针 <em><strong>t</strong></em> 从头节点开始，那么算上头节点，需要经历 <em><strong>k-1</strong></em> 次循环找到第 <em><strong>k-1</strong></em> 个带数据节点。值得注意的是，如果<strong>k &#x3D; 1</strong>的话，也就是在第一个带数据节点的位置插入新节点，不存在第0个带数据节点，此时其实这个第 <em><strong>k-1</strong></em> 个节点就变成了头节点。那么此时明显和头插法是完全一样的。</p><p>图解的话可以参考头插法的图解，是差不多的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_position</span><span class="params">(Linklist *head ,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    Linklist *t=head,*in;  <span class="comment">//t为遍历指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t=t-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            in=(Linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">            in-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;在第 %d 个节点处插入新节点的数据:&quot;</span>,k);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,in-&gt;data);</span><br><span class="line">            in-&gt;next=t-&gt;next;<span class="comment">//插入节点in的next指向当前第k-1个普通节点的next指向的节点</span></span><br><span class="line">            t-&gt;next=in;<span class="comment">//第k-1个普通节点的next重新指向插入的节点in</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">puts</span>(<span class="string">&quot;节点不存在&quot;</span>);        </span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="遍历输出链表数据"><a href="#遍历输出链表数据" class="headerlink" title="遍历输出链表数据"></a>遍历输出链表数据</h2><h3 id="分析及解释-1"><a href="#分析及解释-1" class="headerlink" title="分析及解释"></a>分析及解释</h3><p>我们需要用指针去访问链表中的数据。定义了一个指针<em><strong>t</strong></em>，来对链表的每一个存有数据的节点进行访问并读取数据，直到当前节点为NULL，停止遍历。<br>通俗地来说，就好比一个卸货员工，他挨个从头到尾取下每一节火车车厢的货物，直到最后到达尾部车厢的时候，他便不再取下货物。🤗</p><h3 id="打印链表代码"><a href="#打印链表代码" class="headerlink" title="打印链表代码"></a>打印链表代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_linklist</span><span class="params">(Linklist *head)</span> &#123;</span><br><span class="line">    Linklist *t = head-&gt;next;<span class="comment">//t为遍历指针 访问每个节点数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t-&gt;data);</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定位置删除节点"><a href="#指定位置删除节点" class="headerlink" title="指定位置删除节点"></a>指定位置删除节点</h2><h3 id="分析及解释-2"><a href="#分析及解释-2" class="headerlink" title="分析及解释"></a>分析及解释</h3><p>删除单个节点很容易，只需要找到要删除的节点的前一个节点，然后直接跨过中间这个删除的节点指向删除节点的下一个节点就可以了。</p><h3 id="指定位置删除节点-图解"><a href="#指定位置删除节点-图解" class="headerlink" title="指定位置删除节点 图解"></a>指定位置删除节点 图解</h3><p><img src="/../image/634.png" class="lazyload" data-srcset="/../image/634.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="634"></p><p><img src="/../image/635.png" class="lazyload" data-srcset="/../image/635.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="635"></p><p><img src="/../image/636.png" class="lazyload" data-srcset="/../image/636.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="636"></p><h3 id="指定位置删除节点-代码"><a href="#指定位置删除节点-代码" class="headerlink" title="指定位置删除节点 代码"></a>指定位置删除节点 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delete_position</span><span class="params">(Linklist *head, <span class="type">int</span> k)</span> &#123; <span class="comment">//k表示要删除第k个节点</span></span><br><span class="line">    Linklist *t = head, *del = <span class="literal">NULL</span>;          <span class="comment">//t为遍历指针</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; k - <span class="number">1</span> &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = t-&gt;next;                          <span class="comment">//t指向删除的第k个的前一个节点</span></span><br><span class="line">i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">del = t-&gt;next;                  </span><br><span class="line">t-&gt;next = del-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(del);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;节点不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他基本操作"><a href="#其他基本操作" class="headerlink" title="其他基本操作"></a>其他基本操作</h2><h3 id="x-include-include-include​typedef-int-Elemtype-​typedef-struct-Node-​-Elemtype-data-struct-Node-prior-struct-Node-next-​-DupLooplist-​​​-创建初始双向循环链表-头节点带数据-DupLooplist-Create-DupLooplist-DupLooplist-head-int-n-head-DupLooplist-malloc-sizeof-DupLooplist-head-next-head-head-prior-head-DupLooplist-end-head-printf-“创建初始双向循环链表输入-d-个数据-n”-n-scanf-“-d”-head-data-for-int-i-1-i-n-i-DupLooplist-node-DupLooplist-malloc-sizeof-DupLooplist-node-next-NULL-node-prior-NULL-scanf-“-d”-node-data-​-end-next-node-node-prior-end-end-node-end-next-head-head-prior-end-​-return-head-​​​-遍历打印双向循环链表void-Show-DupLooplist-DupLooplist-head-DupLooplist-t-head-while-true-printf-“-d-“-t-data-t-t-next-if-t-head-break-printf-“-n”-​​-反向遍历打印双向循环链表void-Reverse-DupLooplist-DupLooplist-head-DupLooplist-t-head-prior-DupLooplist-end-head-prior-while-true-printf-“-d-“-t-data-t-t-prior-if-t-end-break-printf-“-n”-​​-插入数据DupLooplist-Insert-DupLooplist-DupLooplist-head-int-pos-Elemtype-data-DupLooplist-node-DupLooplist-malloc-sizeof-DupLooplist-DupLooplist-end-head-prior-node-data-data-node-prior-NULL-node-next-NULL-​-if-pos-1-插在表头-新节点作为表头-node-next-head-head-prior-node-node-prior-end-end-next-node-head-node-​-else-DupLooplist-t-head-for-int-i-1-i-pos-1-i-找到要插入位置的前一个节点-t-t-next-​-if-t-next-head-插在表尾-新节点作为表尾-end-next-node-node-prior-end-node-next-head-head-prior-node-end-node-​-else-插在表中-t-next-prior-node-node-next-t-next-t-next-node-node-prior-t-​-​-return-head-​​-删除双向循环链表指定位置元素DupLooplist-Delete-DupLooplist-DupLooplist-head-int-pos-DupLooplist-t-head-DupLooplist-p-t-prior-for-int-i-1-i-pos-i-找到要删除的节点-以及其前驱节点-t-t-next-p-p-next-​-if-t-if-pos-1-如果是头节点​-p-next-t-next-t-next-prior-p-head-t-next-free-t-return-head-​-else-如果是中间节点​-p-next-t-next-t-next-prior-p-free-t-return-head-​-​​-判断双向循环链表是否对称-（以头尾之间为基准）-bool-IsSymmetry-DupLooplist-head-if-head-next-head-head-prior-head-return-false-​-DupLooplist-front-back-front-head-back-head-prior-双指针-while-front-back-front-prior-back-奇数个或者偶数数个节点-if-front-data-back-data-return-false-front-front-next-back-back-prior-return-true-​​​int-main-DupLooplist-mylist-NULL-mylist-Create-DupLooplist-mylist-10-​​-puts-“-n打印初始状态双向循环链表-“-Show-DupLooplist-mylist-puts-“-n反向遍历打印双向循环链表-“-Reverse-DupLooplist-mylist-printf-“-n”-​​-puts-“判断双向循环链表是否对称-“-if-IsSymmetry-mylist-puts-“此双向循环链表对称”-else-puts-“此双向循环链表不是对称的”-printf-“-n”-​​-puts-“在位置2插入新节点后-“-mylist-Insert-DupLooplist-mylist-2-30-Show-DupLooplist-mylist-printf-“-n”-​​-puts-“删除位置2的节点后-“-mylist-Delete-DupLooplist-mylist-2-Show-DupLooplist-mylist-printf-“-n”-c"><a href="#x-include-include-include​typedef-int-Elemtype-​typedef-struct-Node-​-Elemtype-data-struct-Node-prior-struct-Node-next-​-DupLooplist-​​​-创建初始双向循环链表-头节点带数据-DupLooplist-Create-DupLooplist-DupLooplist-head-int-n-head-DupLooplist-malloc-sizeof-DupLooplist-head-next-head-head-prior-head-DupLooplist-end-head-printf-“创建初始双向循环链表输入-d-个数据-n”-n-scanf-“-d”-head-data-for-int-i-1-i-n-i-DupLooplist-node-DupLooplist-malloc-sizeof-DupLooplist-node-next-NULL-node-prior-NULL-scanf-“-d”-node-data-​-end-next-node-node-prior-end-end-node-end-next-head-head-prior-end-​-return-head-​​​-遍历打印双向循环链表void-Show-DupLooplist-DupLooplist-head-DupLooplist-t-head-while-true-printf-“-d-“-t-data-t-t-next-if-t-head-break-printf-“-n”-​​-反向遍历打印双向循环链表void-Reverse-DupLooplist-DupLooplist-head-DupLooplist-t-head-prior-DupLooplist-end-head-prior-while-true-printf-“-d-“-t-data-t-t-prior-if-t-end-break-printf-“-n”-​​-插入数据DupLooplist-Insert-DupLooplist-DupLooplist-head-int-pos-Elemtype-data-DupLooplist-node-DupLooplist-malloc-sizeof-DupLooplist-DupLooplist-end-head-prior-node-data-data-node-prior-NULL-node-next-NULL-​-if-pos-1-插在表头-新节点作为表头-node-next-head-head-prior-node-node-prior-end-end-next-node-head-node-​-else-DupLooplist-t-head-for-int-i-1-i-pos-1-i-找到要插入位置的前一个节点-t-t-next-​-if-t-next-head-插在表尾-新节点作为表尾-end-next-node-node-prior-end-node-next-head-head-prior-node-end-node-​-else-插在表中-t-next-prior-node-node-next-t-next-t-next-node-node-prior-t-​-​-return-head-​​-删除双向循环链表指定位置元素DupLooplist-Delete-DupLooplist-DupLooplist-head-int-pos-DupLooplist-t-head-DupLooplist-p-t-prior-for-int-i-1-i-pos-i-找到要删除的节点-以及其前驱节点-t-t-next-p-p-next-​-if-t-if-pos-1-如果是头节点​-p-next-t-next-t-next-prior-p-head-t-next-free-t-return-head-​-else-如果是中间节点​-p-next-t-next-t-next-prior-p-free-t-return-head-​-​​-判断双向循环链表是否对称-（以头尾之间为基准）-bool-IsSymmetry-DupLooplist-head-if-head-next-head-head-prior-head-return-false-​-DupLooplist-front-back-front-head-back-head-prior-双指针-while-front-back-front-prior-back-奇数个或者偶数数个节点-if-front-data-back-data-return-false-front-front-next-back-back-prior-return-true-​​​int-main-DupLooplist-mylist-NULL-mylist-Create-DupLooplist-mylist-10-​​-puts-“-n打印初始状态双向循环链表-“-Show-DupLooplist-mylist-puts-“-n反向遍历打印双向循环链表-“-Reverse-DupLooplist-mylist-printf-“-n”-​​-puts-“判断双向循环链表是否对称-“-if-IsSymmetry-mylist-puts-“此双向循环链表对称”-else-puts-“此双向循环链表不是对称的”-printf-“-n”-​​-puts-“在位置2插入新节点后-“-mylist-Insert-DupLooplist-mylist-2-30-Show-DupLooplist-mylist-printf-“-n”-​​-puts-“删除位置2的节点后-“-mylist-Delete-DupLooplist-mylist-2-Show-DupLooplist-mylist-printf-“-n”-c" class="headerlink" title="x #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;​typedef int Elemtype;​typedef struct Node{​    Elemtype data;    struct Node *prior;    struct Node next;​} DupLooplist;​​​&#x2F;&#x2F;创建初始双向循环链表 (头节点带数据)DupLooplist Create_DupLooplist(DupLooplist *head, int n){    head &#x3D; (DupLooplist *)malloc(sizeof(DupLooplist));    head-&gt;next &#x3D; head;    head-&gt;prior &#x3D; head;    DupLooplist *end &#x3D; head;    printf(“创建初始双向循环链表输入 %d 个数据: \n”, n);    scanf(“%d”, &amp;head-&gt;data);    for(int i &#x3D; 1; i &lt; n; i++){        DupLooplist *node &#x3D; (DupLooplist *)malloc(sizeof(DupLooplist));        node-&gt;next &#x3D; NULL;        node-&gt;prior &#x3D; NULL;        scanf(“%d”, &amp;node-&gt;data);​        end-&gt;next &#x3D; node;        node-&gt;prior &#x3D; end;        end &#x3D; node;    }    end-&gt;next &#x3D; head;    head-&gt;prior &#x3D; end;​    return head;}​​​&#x2F;&#x2F;遍历打印双向循环链表void Show_DupLooplist(DupLooplist *head){    DupLooplist *t &#x3D; head;    while(true){        printf(“%d “, t-&gt;data);        t &#x3D; t-&gt;next;        if(t &#x3D;&#x3D; head)            break;    }    printf(“\n”);}​​&#x2F;&#x2F;反向遍历打印双向循环链表void Reverse_DupLooplist(DupLooplist *head){    DupLooplist *t &#x3D; head-&gt;prior;    DupLooplist end &#x3D; head-&gt;prior;    while(true){        printf(“%d “, t-&gt;data);        t &#x3D; t-&gt;prior;        if(t &#x3D;&#x3D; end)            break;    }    printf(“\n”);}​​&#x2F;&#x2F;插入数据DupLooplist Insert_DupLooplist(DupLooplist *head, int pos, Elemtype data){    DupLooplist *node &#x3D; (DupLooplist *)malloc(sizeof(DupLooplist));    DupLooplist *end &#x3D; head-&gt;prior;    node-&gt;data &#x3D; data;    node-&gt;prior &#x3D; NULL;    node-&gt;next &#x3D; NULL;​    if(pos &#x3D;&#x3D; 1){                        &#x2F;&#x2F;插在表头 新节点作为表头                node-&gt;next &#x3D; head;        head-&gt;prior &#x3D; node;        node-&gt;prior &#x3D; end;        end-&gt;next &#x3D; node;        head &#x3D; node;​    }else{        DupLooplist t &#x3D; head;        for(int i &#x3D; 1; i &lt; pos - 1; i++) &#x2F;&#x2F;找到要插入位置的前一个节点            t &#x3D; t-&gt;next;​        if(t-&gt;next &#x3D;&#x3D; head){             &#x2F;&#x2F;插在表尾 新节点作为表尾                        end-&gt;next &#x3D; node;            node-&gt;prior &#x3D; end;            node-&gt;next &#x3D; head;            head-&gt;prior &#x3D; node;                     end &#x3D; node;​        }else{                           &#x2F;&#x2F;插在表中                        t-&gt;next-&gt;prior &#x3D; node;            node-&gt;next &#x3D; t-&gt;next;            t-&gt;next &#x3D; node;            node-&gt;prior &#x3D; t;​        }    }​    return head;}​​&#x2F;&#x2F;删除双向循环链表指定位置元素DupLooplist Delete_DupLooplist(DupLooplist *head, int pos){    DupLooplist *t &#x3D; head;    DupLooplist *p &#x3D; t-&gt;prior;    for(int i &#x3D; 1; i &lt; pos; i++)   &#x2F;&#x2F;找到要删除的节点 以及其前驱节点    {           t &#x3D; t-&gt;next;        p &#x3D; p-&gt;next;    }​    if(t){        if(pos &#x3D;&#x3D; 1){              &#x2F;&#x2F;如果是头节点​            p-&gt;next &#x3D; t-&gt;next;            t-&gt;next-&gt;prior &#x3D; p;            head &#x3D; t-&gt;next;            free(t);            return head;​        }        else{                      &#x2F;&#x2F;如果是中间节点​            p-&gt;next &#x3D; t-&gt;next;            t-&gt;next-&gt;prior &#x3D; p;            free(t);            return head;​        }    }   }​​&#x2F;&#x2F;判断双向循环链表是否对称  （以头尾之间为基准） bool IsSymmetry(DupLooplist *head){    if(head-&gt;next &#x3D;&#x3D; head &amp;&amp; head-&gt;prior &#x3D;&#x3D; head)        return false;​    DupLooplist *front, *back;    front &#x3D; head;    back &#x3D; head-&gt;prior;               &#x2F;&#x2F;双指针    while(front !&#x3D; back &amp;&amp; front-&gt;prior !&#x3D; back){   &#x2F;&#x2F;奇数个或者偶数数个节点        if(front-&gt;data !&#x3D; back-&gt;data)            return false;                    front &#x3D; front-&gt;next;        back &#x3D; back-&gt;prior;    }        return true;}​​​int main(){    DupLooplist *mylist &#x3D; NULL;    mylist &#x3D; Create_DupLooplist(mylist, 10);​​    puts(“\n打印初始状态双向循环链表: “);    Show_DupLooplist(mylist);    puts(“\n反向遍历打印双向循环链表: “);    Reverse_DupLooplist(mylist);    printf(“\n”);​​    puts(“判断双向循环链表是否对称: “);    if(IsSymmetry(mylist))        puts(“此双向循环链表对称”);    else        puts(“此双向循环链表不是对称的”);    printf(“\n”);​​    puts(“在位置2插入新节点后: “);    mylist &#x3D; Insert_DupLooplist(mylist, 2, 30);    Show_DupLooplist(mylist);    printf(“\n”);​​    puts(“删除位置2的节点后: “);    mylist &#x3D; Delete_DupLooplist(mylist, 2);    Show_DupLooplist(mylist);    printf(“\n”);}c"></a>x #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;​typedef int Elemtype;​typedef struct Node{​    Elemtype data;    struct Node *prior;    struct Node <em>next;​} DupLooplist;​​​&#x2F;&#x2F;创建初始双向循环链表 (头节点带数据)DupLooplist</em> Create_DupLooplist(DupLooplist *head, int n){    head &#x3D; (DupLooplist *)malloc(sizeof(DupLooplist));    head-&gt;next &#x3D; head;    head-&gt;prior &#x3D; head;    DupLooplist *end &#x3D; head;    printf(“创建初始双向循环链表输入 %d 个数据: \n”, n);    scanf(“%d”, &amp;head-&gt;data);    for(int i &#x3D; 1; i &lt; n; i++){        DupLooplist *node &#x3D; (DupLooplist *)malloc(sizeof(DupLooplist));        node-&gt;next &#x3D; NULL;        node-&gt;prior &#x3D; NULL;        scanf(“%d”, &amp;node-&gt;data);​        end-&gt;next &#x3D; node;        node-&gt;prior &#x3D; end;        end &#x3D; node;    }    end-&gt;next &#x3D; head;    head-&gt;prior &#x3D; end;​    return head;}​​​&#x2F;&#x2F;遍历打印双向循环链表void Show_DupLooplist(DupLooplist *head){    DupLooplist *t &#x3D; head;    while(true){        printf(“%d “, t-&gt;data);        t &#x3D; t-&gt;next;        if(t &#x3D;&#x3D; head)            break;    }    printf(“\n”);}​​&#x2F;&#x2F;反向遍历打印双向循环链表void Reverse_DupLooplist(DupLooplist *head){    DupLooplist *t &#x3D; head-&gt;prior;    DupLooplist <em>end &#x3D; head-&gt;prior;    while(true){        printf(“%d “, t-&gt;data);        t &#x3D; t-&gt;prior;        if(t &#x3D;&#x3D; end)            break;    }    printf(“\n”);}​​&#x2F;&#x2F;插入数据DupLooplist</em> Insert_DupLooplist(DupLooplist *head, int pos, Elemtype data){    DupLooplist *node &#x3D; (DupLooplist *)malloc(sizeof(DupLooplist));    DupLooplist *end &#x3D; head-&gt;prior;    node-&gt;data &#x3D; data;    node-&gt;prior &#x3D; NULL;    node-&gt;next &#x3D; NULL;​    if(pos &#x3D;&#x3D; 1){                        &#x2F;&#x2F;插在表头 新节点作为表头                node-&gt;next &#x3D; head;        head-&gt;prior &#x3D; node;        node-&gt;prior &#x3D; end;        end-&gt;next &#x3D; node;        head &#x3D; node;​    }else{        DupLooplist <em>t &#x3D; head;        for(int i &#x3D; 1; i &lt; pos - 1; i++) &#x2F;&#x2F;找到要插入位置的前一个节点            t &#x3D; t-&gt;next;​        if(t-&gt;next &#x3D;&#x3D; head){             &#x2F;&#x2F;插在表尾 新节点作为表尾                        end-&gt;next &#x3D; node;            node-&gt;prior &#x3D; end;            node-&gt;next &#x3D; head;            head-&gt;prior &#x3D; node;                     end &#x3D; node;​        }else{                           &#x2F;&#x2F;插在表中                        t-&gt;next-&gt;prior &#x3D; node;            node-&gt;next &#x3D; t-&gt;next;            t-&gt;next &#x3D; node;            node-&gt;prior &#x3D; t;​        }    }​    return head;}​​&#x2F;&#x2F;删除双向循环链表指定位置元素DupLooplist</em> Delete_DupLooplist(DupLooplist *head, int pos){    DupLooplist *t &#x3D; head;    DupLooplist *p &#x3D; t-&gt;prior;    for(int i &#x3D; 1; i &lt; pos; i++)   &#x2F;&#x2F;找到要删除的节点 以及其前驱节点    {           t &#x3D; t-&gt;next;        p &#x3D; p-&gt;next;    }​    if(t){        if(pos &#x3D;&#x3D; 1){              &#x2F;&#x2F;如果是头节点​            p-&gt;next &#x3D; t-&gt;next;            t-&gt;next-&gt;prior &#x3D; p;            head &#x3D; t-&gt;next;            free(t);            return head;​        }        else{                      &#x2F;&#x2F;如果是中间节点​            p-&gt;next &#x3D; t-&gt;next;            t-&gt;next-&gt;prior &#x3D; p;            free(t);            return head;​        }    }   }​​&#x2F;&#x2F;判断双向循环链表是否对称  （以头尾之间为基准） bool IsSymmetry(DupLooplist *head){    if(head-&gt;next &#x3D;&#x3D; head &amp;&amp; head-&gt;prior &#x3D;&#x3D; head)        return false;​    DupLooplist *front, *back;    front &#x3D; head;    back &#x3D; head-&gt;prior;               &#x2F;&#x2F;双指针    while(front !&#x3D; back &amp;&amp; front-&gt;prior !&#x3D; back){   &#x2F;&#x2F;奇数个或者偶数数个节点        if(front-&gt;data !&#x3D; back-&gt;data)            return false;                    front &#x3D; front-&gt;next;        back &#x3D; back-&gt;prior;    }        return true;}​​​int main(){    DupLooplist *mylist &#x3D; NULL;    mylist &#x3D; Create_DupLooplist(mylist, 10);​​    puts(“\n打印初始状态双向循环链表: “);    Show_DupLooplist(mylist);    puts(“\n反向遍历打印双向循环链表: “);    Reverse_DupLooplist(mylist);    printf(“\n”);​​    puts(“判断双向循环链表是否对称: “);    if(IsSymmetry(mylist))        puts(“此双向循环链表对称”);    else        puts(“此双向循环链表不是对称的”);    printf(“\n”);​​    puts(“在位置2插入新节点后: “);    mylist &#x3D; Insert_DupLooplist(mylist, 2, 30);    Show_DupLooplist(mylist);    printf(“\n”);​​    puts(“删除位置2的节点后: “);    mylist &#x3D; Delete_DupLooplist(mylist, 2);    Show_DupLooplist(mylist);    printf(“\n”);}c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素返回节点位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Find_Element</span><span class="params">(Linklist *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    Linklist *t = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="type">int</span> sub = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;data == x)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 的位置为: %d \n&quot;</span>, x, sub);</span><br><span class="line"></span><br><span class="line">t = t-&gt;next;</span><br><span class="line">sub++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;元素不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取指定节点位置元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_position</span><span class="params">(Linklist *head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Linklist *t = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 %d 个节点位置的数据为: %d \n&quot;</span>, k, t-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算链表的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_length</span><span class="params">(Linklist *head)</span>&#123;</span><br><span class="line">    Linklist *t = head-&gt;next;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">len++;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表的长度为: %d \n&quot;</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear_linklist</span><span class="params">(Linklist *head)</span> &#123;</span><br><span class="line">    Linklist *t;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = head-&gt;next;</span><br><span class="line">head-&gt;next = t-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(Linklist *head)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表的奇偶项拆分"><a href="#链表的奇偶项拆分" class="headerlink" title="链表的奇偶项拆分"></a>链表的奇偶项拆分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拆分链表为两个链表 奇偶项拆分</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Depart_linklist</span><span class="params">(Linklist *head, Linklist *la, Linklist *lb)</span>&#123;</span><br><span class="line">    Linklist *t = head-&gt;next;</span><br><span class="line">    Linklist *ra = la, *rb = lb;  <span class="comment">//尾指针 尾插法</span></span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        ra-&gt;next = t;             <span class="comment">//表a</span></span><br><span class="line">        ra = t;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line"></span><br><span class="line">        rb-&gt;next = t;             <span class="comment">//表b</span></span><br><span class="line">        rb = t;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ra-&gt;next = rb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整程序"><a href="#完整程序" class="headerlink" title="完整程序"></a>完整程序</h1><h2 id="完整程序源代码"><a href="#完整程序源代码" class="headerlink" title="完整程序源代码"></a>完整程序源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;        <span class="comment">//数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Elemtype data;           <span class="comment">//结构体数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>       <span class="comment">//结构体指针域</span></span><br><span class="line"></span><br><span class="line">&#125; Linklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的初始化</span></span><br><span class="line">Linklist* <span class="title function_">Initial_linklist</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//向系统申请内存</span></span><br><span class="line">    Linklist *head = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建初始链表  采用尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Create_linklist</span><span class="params">(Linklist *head, <span class="type">int</span> n)</span> &#123;    <span class="comment">//头节点(不带数据)</span></span><br><span class="line">    Linklist *node, *end;                        <span class="comment">//普通节点 尾节点</span></span><br><span class="line">    end = head;                                  <span class="comment">//当链表为空时 头尾指向同一个节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建链表输入 %d 个元素:&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;                <span class="comment">//n为插入普通节点的个数</span></span><br><span class="line">node = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;node-&gt;data);</span><br><span class="line">end-&gt;next = node;                        <span class="comment">//当前end的next指向了新节点node</span></span><br><span class="line">end = node;                              <span class="comment">//end往后移，此时新的节点变成尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    end-&gt;next = <span class="literal">NULL</span>;                            <span class="comment">//end最后置NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_linklist</span><span class="params">(Linklist *head)</span> &#123;</span><br><span class="line">    Linklist *t = head-&gt;next; <span class="comment">//t为遍历指针 访问每个节点数据</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t-&gt;data);</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法 插入单个数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert_Front</span><span class="params">(Linklist *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Linklist *node = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    node-&gt;next = head-&gt;next;      <span class="comment">//新节点node的next指向当前head的next</span></span><br><span class="line">    head-&gt;next = node;            <span class="comment">//head的next重新指向新节点node</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法 插入单个数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert_Back</span><span class="params">(Linklist *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Linklist *node = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    Linklist *end = head;         <span class="comment">//起初end指向头节点</span></span><br><span class="line">    <span class="keyword">while</span> (end-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">end = end-&gt;next;          <span class="comment">//end指针往后移，直到最后一个节点</span></span><br><span class="line">    end-&gt;next = node;  <span class="comment">//当前end的next指向了新节点node</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定位置插入单个数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert_position</span><span class="params">(Linklist *head, <span class="type">int</span> k)</span> &#123; <span class="comment">//k表示在第k个普通节点的位置插入新节点</span></span><br><span class="line">    Linklist *t = head, *in;                  <span class="comment">//t为遍历指针</span></span><br><span class="line">    <span class="comment">//in是要插入的新节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)</span><br><span class="line">t = t-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">in = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">in-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在第 %d 个节点处插入新节点的数据: &quot;</span>, k);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in-&gt;data);</span><br><span class="line">in-&gt;next = t-&gt;next;                  <span class="comment">//插入节点in的next指向当前第k-1个普通节点的next指向的节点</span></span><br><span class="line">t-&gt;next = in;                        <span class="comment">//第k-1个普通节点的next重新指向插入的节点in</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原理和头插法类似 就好像把第k-1个普通节点t看做是头节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;节点不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定位置改变节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Change_position</span><span class="params">(Linklist *head, <span class="type">int</span> n)</span> &#123; <span class="comment">//n表示要改变的是第n个普通节点</span></span><br><span class="line">    Linklist *t = head;                       <span class="comment">//t为遍历指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        t = t-&gt;next;                          <span class="comment">//t指向要改变的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改第 %d 个节点的数据: &quot;</span>, n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t-&gt;data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;节点不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定位置删除节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete_position</span><span class="params">(Linklist *head, <span class="type">int</span> k)</span> &#123; <span class="comment">//k表示要删除第k个节点</span></span><br><span class="line">    Linklist *t = head, *del = <span class="literal">NULL</span>;          <span class="comment">//t为遍历指针</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; k - <span class="number">1</span> &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = t-&gt;next;                          <span class="comment">//t指向删除的第k个的前一个节点</span></span><br><span class="line">i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">del = t-&gt;next;                  </span><br><span class="line">t-&gt;next = del-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(del);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;节点不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找元素返回节点位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Find_Element</span><span class="params">(Linklist *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    Linklist *t = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="type">int</span> sub = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;data == x)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 的位置为: %d \n&quot;</span>, x, sub);</span><br><span class="line"></span><br><span class="line">t = t-&gt;next;</span><br><span class="line">sub++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;元素不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取指定节点位置元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_position</span><span class="params">(Linklist *head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Linklist *t = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 %d 个节点位置的数据为: %d \n&quot;</span>, k, t-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算链表的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_length</span><span class="params">(Linklist *head)</span>&#123;</span><br><span class="line">    Linklist *t = head-&gt;next;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">len++;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表的长度为: %d \n&quot;</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear_linklist</span><span class="params">(Linklist *head)</span> &#123;</span><br><span class="line">    Linklist *t;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = head-&gt;next;</span><br><span class="line">head-&gt;next = t-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(Linklist *head)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//头指针初始化</span></span><br><span class="line">    Linklist *mylist;</span><br><span class="line">    mylist = Initial_linklist();</span><br><span class="line"></span><br><span class="line">    Create_linklist(mylist, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始状态链表:\n&quot;</span>);</span><br><span class="line">    Show_linklist(mylist);</span><br><span class="line"></span><br><span class="line">    Insert_Front(mylist, <span class="number">30</span>);</span><br><span class="line">    Insert_Back(mylist, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表进行首尾插入数字30后:\n&quot;</span>);</span><br><span class="line">    Show_linklist(mylist);</span><br><span class="line"></span><br><span class="line">    Insert_position(mylist, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表进行在第5个节点后插入新节点后:\n&quot;</span>);</span><br><span class="line">    Show_linklist(mylist);</span><br><span class="line"></span><br><span class="line">    Change_position(mylist, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表进行改变第4个数据后:\n&quot;</span>);</span><br><span class="line">    Show_linklist(mylist);</span><br><span class="line"></span><br><span class="line">    Delete_position(mylist, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表进行删除第1个数据后:\n&quot;</span>);</span><br><span class="line">    Show_linklist(mylist);</span><br><span class="line"></span><br><span class="line">    Clear_linklist(mylist);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表进行清空后:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(mylist))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="演示结果"><a href="#演示结果" class="headerlink" title="演示结果"></a>演示结果</h2><p><img src="/../image/637.png" class="lazyload" data-srcset="/../image/637.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="637"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单向链表&quot;&gt;&lt;a href=&quot;#单向链表&quot; class=&quot;headerlink&quot; title=&quot;单向链表&quot;&gt;&lt;/a&gt;单向链表&lt;/h1&gt;&lt;h2 id=&quot;什么是单向链表&quot;&gt;&lt;a href=&quot;#什么是单向链表&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    <category term="数据结构" scheme="https://5m10v3.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>双向链表及双向循环链表(C语言)</title>
    <link href="https://5m10v3.github.io/2024/04/11/[%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84]%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/"/>
    <id>https://5m10v3.github.io/2024/04/11/[%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84]%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2024-04-10T16:00:00.000Z</published>
    <updated>2024-04-11T16:26:57.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><h2 id="双向链表概念"><a href="#双向链表概念" class="headerlink" title="双向链表概念"></a>双向链表概念</h2><p>双向链表也叫双链表，其每个数据结点中都有两个指针，分别指向直接<strong>后继</strong>和直接<strong>前驱</strong>。在单向链表中若要找到某个节点的前驱节点，需要先遍历到这个节点，然后再遍历一次找到其前驱节点，这无疑是十分低效的。而双向链表可以做到正向反向遍历，由此相比单向链表可以更高效地找到某个节点的前驱节点。</p><h1 id="双向链表的创建"><a href="#双向链表的创建" class="headerlink" title="双向链表的创建"></a>双向链表的创建</h1><h2 id="双向链表的节点构成"><a href="#双向链表的节点构成" class="headerlink" title="双向链表的节点构成"></a>双向链表的节点构成</h2><h4 id="双向链表的单个节点含有两个指针域，一个值域。"><a href="#双向链表的单个节点含有两个指针域，一个值域。" class="headerlink" title="双向链表的单个节点含有两个指针域，一个值域。"></a>双向链表的单个节点含有两个指针域，一个值域。</h4><p><img src="/../image/638.png" class="lazyload" data-srcset="/../image/638.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="638"></p><p>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span> <span class="comment">//前驱指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//后驱指针</span></span><br><span class="line">&#125;Duplist;</span><br></pre></td></tr></table></figure><h2 id="双向链表的初始化创建"><a href="#双向链表的初始化创建" class="headerlink" title="双向链表的初始化创建"></a>双向链表的初始化创建</h2><p>双向链表基本上就是在单向链表的基础上多了一个前驱指针，用类似的方式建立每个节点与前驱之间关系就可以了🤪。<br>创建初始双向链表一般都是在链表尾部插入新节点：<br>（1）将 <strong>end</strong> 的 <em><strong>next</strong></em> 指向新节点 <strong>node</strong>;<br>（2）将 <strong>node</strong> 的 <em><strong>prior</strong></em> 指向 <strong>end</strong>。</p><h4 id="双向链表图"><a href="#双向链表图" class="headerlink" title="双向链表图"></a>双向链表图</h4><p><img src="/../image/639.png" class="lazyload" data-srcset="/../image/639.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="639"></p><h4 id="双向链表创建代码"><a href="#双向链表创建代码" class="headerlink" title="双向链表创建代码"></a>双向链表创建代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Duplist *<span class="title function_">Create_DuplistxLinklist</span><span class="params">(Duplist *head,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    head = (Duplist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Duplist));</span><br><span class="line">    head-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Duplist *end=head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建双向链表输入 %d 个数据: &quot;</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;head-&gt;data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化结点</span></span><br><span class="line">        Duplist *node = (Duplist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Duplist));</span><br><span class="line">        node-&gt;prior=<span class="literal">NULL</span>:</span><br><span class="line">        node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">        </span><br><span class="line">        end-&gt;next=node;   <span class="comment">//end的next指向新节点node</span></span><br><span class="line">        node-&gt;prior=end; <span class="comment">//新节点node的前驱prior指向之前的end</span></span><br><span class="line">        end=node;           <span class="comment">//end指向最后的node节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向链表的插入操作"><a href="#双向链表的插入操作" class="headerlink" title="双向链表的插入操作"></a>双向链表的插入操作</h1><p>双向链表的插入分为三种，分别为表头插入，表中插入和表尾插入。</p><h2 id="表头插入"><a href="#表头插入" class="headerlink" title="表头插入"></a>表头插入</h2><h4 id="表头插入操作-这里顺序无所谓-："><a href="#表头插入操作-这里顺序无所谓-：" class="headerlink" title="表头插入操作(这里顺序无所谓)："></a>表头插入操作(这里顺序无所谓)：</h4><p>（1）将 <strong>head</strong> 的 <em><strong>prior</strong></em> 指向新节点 <strong>node</strong>;<br>（2）将 <strong>node</strong> 的 <em><strong>next</strong></em> 指向 <strong>head</strong>；<br>（3）将 <strong>head</strong> 指向新节点 <strong>node</strong>。</p><p>笔者自己的理解</p><p>既然是表头了，那肯定用的是前驱指针</p><p>前驱指针指向要插入的节点，由于是双向链表肯定插入的节点的后驱指针要指向head</p><h4 id="表头插入图解"><a href="#表头插入图解" class="headerlink" title="表头插入图解"></a>表头插入图解</h4><p><img src="/../image/640.jpg" class="lazyload" data-srcset="/../image/640.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="640"></p><h2 id="表中插入"><a href="#表中插入" class="headerlink" title="表中插入"></a>表中插入</h2><h4 id="表中插入操作-这里的顺序不能轻易改变，画图有助于理解-："><a href="#表中插入操作-这里的顺序不能轻易改变，画图有助于理解-：" class="headerlink" title="表中插入操作(这里的顺序不能轻易改变，画图有助于理解)："></a>表中插入操作(这里的顺序不能轻易改变，画图有助于理解)：</h4><p>找到插入位置处pos之前的节点 <strong>t</strong>;<br>（1）将 <strong>t</strong> 的 <em><strong>next</strong></em> 的 <em><strong>prior</strong></em> 指向新节点 <strong>node</strong>;<br>（2）将 <strong>node</strong> 的 <em><strong>next</strong></em> 指向 <strong>t</strong> 的 <em><strong>next</strong></em>;<br>（3）将 <strong>t</strong> 的 <em><strong>next</strong></em> 指向新节点 <strong>node</strong>;<br>（4）将 <strong>node</strong> 的 <em><strong>prior</strong></em> 指向 <strong>t</strong>。</p><h4 id="表中插入图解"><a href="#表中插入图解" class="headerlink" title="表中插入图解"></a>表中插入图解</h4><p><img src="/../image/641.png" class="lazyload" data-srcset="/../image/641.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="641"></p><h2 id="表尾插入"><a href="#表尾插入" class="headerlink" title="表尾插入"></a>表尾插入</h2><h4 id="表尾插入操作："><a href="#表尾插入操作：" class="headerlink" title="表尾插入操作："></a>表尾插入操作：</h4><p>（1）将 <strong>end</strong> 的 <em><strong>next</strong></em> 指向新节点 <strong>node</strong>;<br>（2）将 <strong>node</strong> 的 <em><strong>prior</strong></em> 指向 <strong>end</strong>;<br>（3）将 <strong>end</strong> 指向新节点 <strong>node</strong>。</p><p>表尾操作，意思就是跟表头插入相反</p><h4 id="表尾插入图解"><a href="#表尾插入图解" class="headerlink" title="表尾插入图解"></a>表尾插入图解</h4><p><img src="/../image/641.png" class="lazyload" data-srcset="/../image/641.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="641"></p><h2 id="双向链表插入操作代码"><a href="#双向链表插入操作代码" class="headerlink" title="双向链表插入操作代码"></a>双向链表插入操作代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入新节点(包含三种情况 头插 尾插 和 指定位置插入)</span></span><br><span class="line">Duplist *<span class="title function_">Insert_DuplistxLinklist</span><span class="params">(Duplist *head,<span class="type">int</span> pos,<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//初始化插入新节点</span></span><br><span class="line">   Duplist *node =(Duplist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Duplist));</span><br><span class="line">   node-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">   node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(pos==<span class="number">1</span>) <span class="comment">//插在链表头的情况</span></span><br><span class="line">   &#123;</span><br><span class="line">       head-&gt;prior=node;<span class="comment">//新节点node的next指向之前的头head</span></span><br><span class="line">       node-&gt;next=head;<span class="comment">//之前的head的前驱prior指向了node</span></span><br><span class="line">       head=node;<span class="comment">//head重新指向了插在表头的新节点</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Duplist *t = head; <span class="comment">//t为遍历指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;pos<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;next==<span class="literal">NULL</span>)<span class="comment">//插在链表尾的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                t-&gt;next=node;</span><br><span class="line">                node-&gt;prior=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//插在表中的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                t-&gt;next-&gt;prior=node;<span class="comment">////t的下一个节点(要代替位置的节点)的前驱指向新node</span></span><br><span class="line">                node-&gt;next=t-&gt;next;<span class="comment">//新node的next指向了之前t的下一个节点</span></span><br><span class="line">                t-&gt;next = node;               <span class="comment">//t的next重新指向新node</span></span><br><span class="line">    node-&gt;prior = t;              <span class="comment">//node前驱prior指向了t </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向链表的删除操作"><a href="#双向链表的删除操作" class="headerlink" title="双向链表的删除操作"></a>双向链表的删除操作</h1><p>双向链表删除节点也可以分成三种，表头删除、表中删除和表尾删除。</p><h2 id="表头删除"><a href="#表头删除" class="headerlink" title="表头删除"></a>表头删除</h2><h3 id="表头删除操作"><a href="#表头删除操作" class="headerlink" title="表头删除操作:"></a>表头删除操作:</h3><p>（1）<strong>head</strong> 后移;<br>（2）此时的 <strong>head</strong> 的 <em><strong>prior</strong></em> 置NULL。<br>操作比较简单就省略图解了</p><h2 id="表中删除"><a href="#表中删除" class="headerlink" title="表中删除"></a>表中删除</h2><h3 id="表中删除操作"><a href="#表中删除操作" class="headerlink" title="表中删除操作:"></a>表中删除操作:</h3><p>（1）<strong>t</strong> 的 <em><strong>prior</strong></em> 的 <em><strong>next</strong></em> 指向 <strong>t</strong> 的 <em><strong>next</strong></em>；<br>（2）<strong>t</strong> 的 <em><strong>next</strong></em> 的 <em><strong>prior</strong></em> 指向 <strong>t</strong> 的 <em><strong>prior</strong></em>。</p><h3 id="表中删除图解"><a href="#表中删除图解" class="headerlink" title="表中删除图解"></a>表中删除图解</h3><p><img src="/../image/642.png" class="lazyload" data-srcset="/../image/642.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="642"></p><h2 id="表尾删除"><a href="#表尾删除" class="headerlink" title="表尾删除"></a>表尾删除</h2><h3 id="表尾删除操作"><a href="#表尾删除操作" class="headerlink" title="表尾删除操作"></a>表尾删除操作</h3><p>如果 <strong>t</strong> 指向表尾<br>（1）直接将此时 <strong>t</strong> 的 <em><strong>prior</strong></em> 的 <em><strong>next</strong></em> 置 NULL。<br>操作比较简单就省略图解了</p><h2 id="双向链表删除操作代码"><a href="#双向链表删除操作代码" class="headerlink" title="双向链表删除操作代码"></a>双向链表删除操作代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定位置节点</span></span><br><span class="line">Duplist* <span class="title function_">Delete_DuplexLinklist</span><span class="params">(Duplist *head, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">Duplist *t = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos; i++)</span><br><span class="line">t = t-&gt;next;                  <span class="comment">//找到要删除的节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;prior == <span class="literal">NULL</span>) &#123;       <span class="comment">//如果是头节点</span></span><br><span class="line">head = t-&gt;next;           <span class="comment">//head往后移</span></span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line">head-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;next == <span class="literal">NULL</span>) &#123; <span class="comment">//如果是尾节点</span></span><br><span class="line">t-&gt;prior-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//表尾的前一个节点的next置NULL</span></span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                      <span class="comment">//删除表中节点的情况</span></span><br><span class="line">t-&gt;prior-&gt;next = t-&gt;next; <span class="comment">//要删除节点的前一个节点的next跨越直接指向下下个节点</span></span><br><span class="line">t-&gt;next-&gt;prior = t-&gt;prior;<span class="comment">//要删除节点的后一个节点的prior跨越指向上上个节点</span></span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;节点不存在\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向链表测试代码（附带其他操作）"><a href="#双向链表测试代码（附带其他操作）" class="headerlink" title="双向链表测试代码（附带其他操作）"></a>双向链表测试代码（附带其他操作）</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">Elemtype data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span>      <span class="comment">//前驱指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>       <span class="comment">//后驱指针</span></span><br><span class="line"></span><br><span class="line">&#125; Duplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建初始化双向链表(头节点有数据，便于表头插入，要与单向链表区分)</span></span><br><span class="line">Duplist *<span class="title function_">Create_DuplexLinklist</span><span class="params">(Duplist *head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">head = (Duplist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Duplist));</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;prior = <span class="literal">NULL</span>;            </span><br><span class="line">Duplist *end = head;                       <span class="comment">//用于在尾部插入新节点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建双向链表输入 %d 个数据: &quot;</span>, n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;head-&gt;data);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">Duplist *node = (Duplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Duplist));</span><br><span class="line">node-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;node-&gt;data);</span><br><span class="line"></span><br><span class="line">end-&gt;next = node;                      <span class="comment">//之前的end的next指向新节点node</span></span><br><span class="line">node-&gt;prior = end;                     <span class="comment">//新节点node的前驱prior指向之前的end</span></span><br><span class="line">end = node;                            <span class="comment">//end永远指向最后的node节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新节点(包含三种情况 头插 尾插 和 指定位置插入)</span></span><br><span class="line">Duplist *<span class="title function_">Insert_DuplexLinklist</span><span class="params">(Duplist *head, <span class="type">int</span> pos, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">Duplist *node = (Duplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Duplist));</span><br><span class="line">node-&gt;data = data;</span><br><span class="line">node-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//pos表示要插入的位置（head为1）</span></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">1</span>) &#123;                       <span class="comment">//插在链表头的情况</span></span><br><span class="line">node-&gt;next = head;                <span class="comment">//新节点node的next指向之前的头head</span></span><br><span class="line">head-&gt;prior = node;               <span class="comment">//之前的head的前驱prior指向了node</span></span><br><span class="line">head = node;                      <span class="comment">//head重新指向了插在表头的新节点</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Duplist *t = head;                <span class="comment">//t为遍历指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos - <span class="number">1</span>; i++) <span class="comment">//t指向要插入位置的前一个节点</span></span><br><span class="line">t = t-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t-&gt;next == <span class="literal">NULL</span>) &#123;            <span class="comment">//插在链表尾的情况</span></span><br><span class="line">t-&gt;next = node;               <span class="comment">//t指向表尾，t的next指向新节点node</span></span><br><span class="line">node-&gt;prior = t;              <span class="comment">//新节点node的前驱prior指向t</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//插在表中的情况</span></span><br><span class="line">t-&gt;next-&gt;prior = node;        <span class="comment">//t的下一个节点(要代替位置的节点)的前驱指向新node</span></span><br><span class="line">node-&gt;next = t-&gt;next;         <span class="comment">//新node的next指向了之前t的下一个节点</span></span><br><span class="line">t-&gt;next = node;               <span class="comment">//t的next重新指向新node</span></span><br><span class="line">node-&gt;prior = t;              <span class="comment">//node前驱prior指向了t</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定位置节点</span></span><br><span class="line">Duplist* <span class="title function_">Delete_DuplexLinklist</span><span class="params">(Duplist *head, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">Duplist *t = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos; i++)</span><br><span class="line">t = t-&gt;next;                  <span class="comment">//找到要删除的节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;prior == <span class="literal">NULL</span>) &#123;       <span class="comment">//如果是头节点</span></span><br><span class="line">head = t-&gt;next;           <span class="comment">//head往后移</span></span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line">head-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;next == <span class="literal">NULL</span>) &#123; <span class="comment">//如果是尾节点</span></span><br><span class="line">t-&gt;prior-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//表尾的前一个节点的next置NULL</span></span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                      <span class="comment">//删除表中节点的情况</span></span><br><span class="line">t-&gt;prior-&gt;next = t-&gt;next; <span class="comment">//要删除节点的前一个节点的next跨越直接指向下下个节点</span></span><br><span class="line">t-&gt;next-&gt;prior = t-&gt;prior;<span class="comment">//要删除节点的后一个节点的prior跨越指向上上个节点</span></span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;节点不存在\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取单个数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read_DuplexLinklist</span><span class="params">(Duplist *head, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">Duplist *t = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos; i++)</span><br><span class="line">t = t-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第 %d 个位置的数据为 %d&quot;</span>, pos, t-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;节点不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变指定位置数据</span></span><br><span class="line">Duplist* <span class="title function_">Change_DuplexLinklist</span><span class="params">(Duplist *head, <span class="type">int</span> pos, <span class="type">int</span> data)</span>&#123;</span><br><span class="line">Duplist *t = head;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos; i++)</span><br><span class="line">t = t-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t != <span class="literal">NULL</span>)</span><br><span class="line">t-&gt;data = data;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;节点不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找数据返回下标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find_DuplexLinklist</span><span class="params">(Duplist *head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">Duplist *t = head;</span><br><span class="line"><span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;data == n) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该数据的位置为 %d&quot;</span>, pos);</span><br><span class="line">&#125;</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历打印双向链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_DuplexLinklist</span><span class="params">(Duplist *head)</span> &#123;</span><br><span class="line">Duplist *t = head;</span><br><span class="line"><span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t-&gt;data);</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反向打印双向链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reverse_DuplexLinklist</span><span class="params">(Duplist *head)</span>&#123;</span><br><span class="line">Duplist *t = head;</span><br><span class="line"><span class="keyword">while</span> (t-&gt;next != <span class="literal">NULL</span>)           <span class="comment">//指向最后一个节点</span></span><br><span class="line">t = t-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">t = t-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Duplist *mylist = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">mylist = Create_DuplexLinklist(mylist, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;初始状态双向链表:&quot;</span>);</span><br><span class="line">Show_DuplexLinklist(mylist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mylist = Insert_DuplexLinklist(mylist, <span class="number">11</span>, <span class="number">30</span>);</span><br><span class="line">mylist = Insert_DuplexLinklist(mylist, <span class="number">1</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;在头和尾 的位置插入数据30后:&quot;</span>);</span><br><span class="line">Show_DuplexLinklist(mylist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">mylist = Change_DuplexLinklist(mylist,<span class="number">5</span>,<span class="number">22</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;改变第 5 的位置数据为 22 后:&quot;</span>);</span><br><span class="line">Show_DuplexLinklist(mylist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">mylist = Delete_DuplexLinklist(mylist, <span class="number">8</span>);</span><br><span class="line">mylist = Delete_DuplexLinklist(mylist, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;删除第 1 和 8 的位置数据后:&quot;</span>);</span><br><span class="line">Show_DuplexLinklist(mylist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;双向链表反向输出:&quot;</span>);</span><br><span class="line">Reverse_DuplexLinklist(mylist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/643.png" class="lazyload" data-srcset="/../image/643.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="643"></p><h1 id="双向循环链表以及判断对称"><a href="#双向循环链表以及判断对称" class="headerlink" title="双向循环链表以及判断对称"></a>双向循环链表以及判断对称</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"></span><br><span class="line">Elemtype data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; DupLooplist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建初始双向循环链表 (头节点带数据)</span></span><br><span class="line">DupLooplist* <span class="title function_">Create_DupLooplist</span><span class="params">(DupLooplist *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">head = (DupLooplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DupLooplist));</span><br><span class="line">head-&gt;next = head;</span><br><span class="line">head-&gt;prior = head;</span><br><span class="line">DupLooplist *end = head;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建初始双向循环链表输入 %d 个数据: \n&quot;</span>, n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;head-&gt;data);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">DupLooplist *node = (DupLooplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DupLooplist));</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;node-&gt;data);</span><br><span class="line"></span><br><span class="line">end-&gt;next = node;</span><br><span class="line">node-&gt;prior = end;</span><br><span class="line">end = node;</span><br><span class="line">&#125;</span><br><span class="line">end-&gt;next = head;</span><br><span class="line">head-&gt;prior = end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历打印双向循环链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_DupLooplist</span><span class="params">(DupLooplist *head)</span>&#123;</span><br><span class="line">DupLooplist *t = head;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t-&gt;data);</span><br><span class="line">t = t-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(t == head)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//反向遍历打印双向循环链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reverse_DupLooplist</span><span class="params">(DupLooplist *head)</span>&#123;</span><br><span class="line">DupLooplist *t = head-&gt;prior;</span><br><span class="line">DupLooplist *end = head-&gt;prior;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t-&gt;data);</span><br><span class="line">t = t-&gt;prior;</span><br><span class="line"><span class="keyword">if</span>(t == end)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">DupLooplist* <span class="title function_">Insert_DupLooplist</span><span class="params">(DupLooplist *head, <span class="type">int</span> pos, Elemtype data)</span>&#123;</span><br><span class="line">DupLooplist *node = (DupLooplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DupLooplist));</span><br><span class="line">DupLooplist *end = head-&gt;prior;</span><br><span class="line">node-&gt;data = data;</span><br><span class="line">node-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos == <span class="number">1</span>)&#123;                        <span class="comment">//插在表头 新节点作为表头</span></span><br><span class="line"></span><br><span class="line">node-&gt;next = head;</span><br><span class="line">head-&gt;prior = node;</span><br><span class="line">node-&gt;prior = end;</span><br><span class="line">end-&gt;next = node;</span><br><span class="line">head = node;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">DupLooplist *t = head;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos - <span class="number">1</span>; i++) <span class="comment">//找到要插入位置的前一个节点</span></span><br><span class="line">t = t-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;next == head)&#123;             <span class="comment">//插在表尾 新节点作为表尾</span></span><br><span class="line">        </span><br><span class="line">        end-&gt;next = node;</span><br><span class="line">        node-&gt;prior = end;</span><br><span class="line">        node-&gt;next = head;</span><br><span class="line">        head-&gt;prior = node;        </span><br><span class="line">        end = node;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                           <span class="comment">//插在表中</span></span><br><span class="line">        </span><br><span class="line">        t-&gt;next-&gt;prior = node;</span><br><span class="line">        node-&gt;next = t-&gt;next;</span><br><span class="line">        t-&gt;next = node;</span><br><span class="line">        node-&gt;prior = t;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除双向循环链表指定位置元素</span></span><br><span class="line">DupLooplist* <span class="title function_">Delete_DupLooplist</span><span class="params">(DupLooplist *head, <span class="type">int</span> pos)</span>&#123;</span><br><span class="line">DupLooplist *t = head;</span><br><span class="line">DupLooplist *p = t-&gt;prior;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos; i++)   <span class="comment">//找到要删除的节点 以及其前驱节点</span></span><br><span class="line">&#123;   </span><br><span class="line">t = t-&gt;next;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">1</span>)&#123;              <span class="comment">//如果是头节点</span></span><br><span class="line"></span><br><span class="line">        p-&gt;next = t-&gt;next;</span><br><span class="line">    t-&gt;next-&gt;prior = p;</span><br><span class="line">    head = t-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                      <span class="comment">//如果是中间节点</span></span><br><span class="line"></span><br><span class="line">        p-&gt;next = t-&gt;next;</span><br><span class="line">        t-&gt;next-&gt;prior = p;</span><br><span class="line">        <span class="built_in">free</span>(t);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双向循环链表是否对称  （以头尾之间为基准） </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsSymmetry</span><span class="params">(DupLooplist *head)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head-&gt;next == head &amp;&amp; head-&gt;prior == head)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">DupLooplist *front, *back;</span><br><span class="line">front = head;</span><br><span class="line">back = head-&gt;prior;               <span class="comment">//双指针</span></span><br><span class="line"><span class="keyword">while</span>(front != back &amp;&amp; front-&gt;prior != back)&#123;   <span class="comment">//奇数个或者偶数数个节点</span></span><br><span class="line"><span class="keyword">if</span>(front-&gt;data != back-&gt;data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">front = front-&gt;next;</span><br><span class="line">back = back-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">DupLooplist *mylist = <span class="literal">NULL</span>;</span><br><span class="line">mylist = Create_DupLooplist(mylist, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n打印初始状态双向循环链表: &quot;</span>);</span><br><span class="line">Show_DupLooplist(mylist);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n反向遍历打印双向循环链表: &quot;</span>);</span><br><span class="line">Reverse_DupLooplist(mylist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;判断双向循环链表是否对称: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IsSymmetry(mylist))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;此双向循环链表对称&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;此双向循环链表不是对称的&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;在位置2插入新节点后: &quot;</span>);</span><br><span class="line">mylist = Insert_DupLooplist(mylist, <span class="number">2</span>, <span class="number">30</span>);</span><br><span class="line">Show_DupLooplist(mylist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;删除位置2的节点后: &quot;</span>);</span><br><span class="line">mylist = Delete_DupLooplist(mylist, <span class="number">2</span>);</span><br><span class="line">Show_DupLooplist(mylist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双向链表&quot;&gt;&lt;a href=&quot;#双向链表&quot; class=&quot;headerlink&quot; title=&quot;双向链表&quot;&gt;&lt;/a&gt;双向链表&lt;/h1&gt;&lt;h2 id=&quot;双向链表概念&quot;&gt;&lt;a href=&quot;#双向链表概念&quot; class=&quot;headerlink&quot; title=&quot;双向链表概</summary>
      
    
    
    
    <category term="数据结构" scheme="https://5m10v3.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Windows内核驱动学习(四)</title>
    <link href="https://5m10v3.github.io/2024/04/10/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
    <id>https://5m10v3.github.io/2024/04/10/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/</id>
    <published>2024-04-09T16:00:00.000Z</published>
    <updated>2024-04-13T05:17:43.516Z</updated>
    
    <content type="html"><![CDATA[<p>这里笔者用的系统为Win10，virtual studio2019</p><h2 id="配置驱动开发环境"><a href="#配置驱动开发环境" class="headerlink" title="配置驱动开发环境"></a>配置驱动开发环境</h2><p>这里参考官方文档<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk</a></p><p>笔者建议下载virtual studio2019(比较稳定)+SDK10.0.22000.0,还有一个原因就是生成的驱动在win7，win10，win11都能使用 </p><p>然后下载的WDK要跟SDK对应</p><h2 id="第一个驱动"><a href="#第一个驱动" class="headerlink" title="第一个驱动"></a>第一个驱动</h2><p><img src="/../image/617.png" class="lazyload" data-srcset="/../image/617.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="617"></p><p>我们可以点击PDRIVER_OBJECT 然后F12看它的结构</p><p><img src="/../image/618.png" class="lazyload" data-srcset="/../image/618.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="618"></p><p>这里的分别就是驱动的一些配置</p><p>我们把生成的sys文件拖入到虚拟机中进行双机调试</p><p><img src="/../image/619.png" class="lazyload" data-srcset="/../image/619.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="619"></p><p>这里笔者用的是IDA7.7</p><p><img src="/../image/620.png" class="lazyload" data-srcset="/../image/620.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="620"></p><p>我们可以看到它是先调用了这个cookie检查，然后才跳到真正的DriverEntry处</p><p><img src="/../image/621.png" class="lazyload" data-srcset="/../image/621.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="621"></p><p>然后我们dt pReg</p><p><img src="/../image/622.png" class="lazyload" data-srcset="/../image/622.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="622"></p><p>我们可以看到寄存器安装的位置</p><p>这个时候我们在虚拟机上看一下注册表编辑器</p><p><img src="/../image/623.png" class="lazyload" data-srcset="/../image/623.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="623"></p><p>我们发现这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\??\C:\Users\Administrator\Desktop\MyDriver1.sys   为什么前面有两个问号，这个表示根，后面才表示盘符</span><br></pre></td></tr></table></figure><p>我们还可以看到<strong>Start</strong>后面的数据为3</p><p>在这里其实有5种数字 0，1，2，3，4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.  代表进入bios之后立马启动（自启用）</span><br><span class="line">1.  启动了bios系统之后再启动</span><br><span class="line">2.  等winlogon.exe进程启动之后再自启动</span><br><span class="line">3.  手动启动</span><br><span class="line">4.  禁止启动</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里笔者用的系统为Win10，virtual studio2019&lt;/p&gt;
&lt;h2 id=&quot;配置驱动开发环境&quot;&gt;&lt;a href=&quot;#配置驱动开发环境&quot; class=&quot;headerlink&quot; title=&quot;配置驱动开发环境&quot;&gt;&lt;/a&gt;配置驱动开发环境&lt;/h2&gt;&lt;p&gt;这里参考官</summary>
      
    
    
    
    <category term="内核驱动" scheme="https://5m10v3.github.io/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="Windows内核驱动开发" scheme="https://5m10v3.github.io/tags/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2024长城杯-ez_driver复现与思考</title>
    <link href="https://5m10v3.github.io/2024/04/09/2024%E9%95%BF%E5%9F%8E%E6%9D%AF-ez_driver%E5%A4%8D%E7%8E%B0%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>https://5m10v3.github.io/2024/04/09/2024%E9%95%BF%E5%9F%8E%E6%9D%AF-ez_driver%E5%A4%8D%E7%8E%B0%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2024-04-08T16:00:00.000Z</published>
    <updated>2024-05-30T09:11:45.923Z</updated>
    
    <content type="html"><![CDATA[<p>当时这道题在比赛的时候，因为自己对c语言的学艺不精，没有解出来<br>这是道驱动逆向题，但是最简单的方法用不到动调</p><p>以下是主要加密程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_140001110</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+20h] [rbp-B8h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+28h] [rbp-B0h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-ACh]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+30h] [rbp-A8h]</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+34h] [rbp-A4h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [rsp+38h] [rbp-A0h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [rsp+3Ch] [rbp-9Ch]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [rsp+40h] [rbp-98h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v11; <span class="comment">// [rsp+44h] [rbp-94h]</span></span><br><span class="line">  PCSTR Format; <span class="comment">// [rsp+48h] [rbp-90h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [rsp+50h] [rbp-88h]</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [rsp+54h] [rbp-84h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v15; <span class="comment">// [rsp+58h] [rbp-80h]</span></span><br><span class="line">  _DWORD *v16; <span class="comment">// [rsp+60h] [rbp-78h]</span></span><br><span class="line">  <span class="type">char</span> *v17; <span class="comment">// [rsp+68h] [rbp-70h]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [rsp+70h] [rbp-68h]</span></span><br><span class="line">  <span class="type">int</span> v19; <span class="comment">// [rsp+74h] [rbp-64h]</span></span><br><span class="line">  PCSTR v20; <span class="comment">// [rsp+78h] [rbp-60h]</span></span><br><span class="line">  <span class="type">int</span> v21[<span class="number">4</span>]; <span class="comment">// [rsp+80h] [rbp-58h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v22[<span class="number">40</span>]; <span class="comment">// [rsp+90h] [rbp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v16 = (_DWORD *)<span class="built_in">sub_140001890</span>(a2);</span><br><span class="line">  v13 = v16[<span class="number">6</span>];</span><br><span class="line">  Format = *(PCSTR *)(a2 + <span class="number">24</span>);</span><br><span class="line">  v11 = v16[<span class="number">4</span>];</span><br><span class="line">  v18 = v16[<span class="number">2</span>];</span><br><span class="line">  v10 = v13;</span><br><span class="line">  <span class="keyword">if</span> ( v13 == <span class="number">0x222000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(&amp;byte_140001F80);</span><br><span class="line">    <span class="built_in">memset</span>(v22, <span class="number">0</span>, <span class="built_in">sizeof</span>(v22));</span><br><span class="line">    v20 = Format;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v11; ++i )</span><br><span class="line">      v22[i] = v20[i];</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j += <span class="number">8</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = <span class="number">0</span>;</span><br><span class="line">      v5 = <span class="number">0</span>;</span><br><span class="line">      v4 = (<span class="type">unsigned</span> __int8)v22[j] &lt;&lt; <span class="number">24</span>;</span><br><span class="line">      v4 += (<span class="type">unsigned</span> __int8)v22[j + <span class="number">1</span>] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">      v4 += (<span class="type">unsigned</span> __int8)v22[j + <span class="number">2</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">      v4 += (<span class="type">unsigned</span> __int8)v22[j + <span class="number">3</span>];</span><br><span class="line">      v5 = (<span class="type">unsigned</span> __int8)v22[j + <span class="number">4</span>] &lt;&lt; <span class="number">24</span>;</span><br><span class="line">      v5 += (<span class="type">unsigned</span> __int8)v22[j + <span class="number">5</span>] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">      v5 += (<span class="type">unsigned</span> __int8)v22[j + <span class="number">6</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">      v5 += (<span class="type">unsigned</span> __int8)v22[j + <span class="number">7</span>];</span><br><span class="line">      v21[<span class="number">0</span>] = <span class="number">6699</span>;</span><br><span class="line">      v21[<span class="number">1</span>] = <span class="number">14925</span>;</span><br><span class="line">      v21[<span class="number">2</span>] = <span class="number">24175</span>;</span><br><span class="line">      v21[<span class="number">3</span>] = <span class="number">43571</span>;</span><br><span class="line">      v19 = <span class="number">2</span>;</span><br><span class="line">      v14 = <span class="number">33</span>;</span><br><span class="line">      <span class="built_in">xtea</span>(<span class="number">33</span>i64, &amp;v4, v21);</span><br><span class="line">      v22[j] = <span class="built_in">HIBYTE</span>(v4);</span><br><span class="line">      v22[j + <span class="number">1</span>] = <span class="built_in">BYTE2</span>(v4);</span><br><span class="line">      v22[j + <span class="number">2</span>] = <span class="built_in">BYTE1</span>(v4);</span><br><span class="line">      v22[j + <span class="number">3</span>] = v4;</span><br><span class="line">      v22[j + <span class="number">4</span>] = <span class="built_in">HIBYTE</span>(v5);</span><br><span class="line">      v22[j + <span class="number">5</span>] = <span class="built_in">BYTE2</span>(v5);</span><br><span class="line">      v22[j + <span class="number">6</span>] = <span class="built_in">BYTE1</span>(v5);</span><br><span class="line">      v22[j + <span class="number">7</span>] = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    v8 = <span class="number">0</span>;</span><br><span class="line">    v17 = v22;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v15 = v8;</span><br><span class="line">      <span class="built_in">sub_140001A70</span>(v17, v8++);</span><br><span class="line">      v17 += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( (<span class="type">int</span>)v8 &lt; <span class="number">2</span> );</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; <span class="number">32</span>; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v22[k] == byte_140004000[k] )</span><br><span class="line">        ++v9;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(&amp;byte_140001F90);</span><br><span class="line">    <span class="keyword">if</span> ( v9 == <span class="number">32</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>((<span class="type">char</span> *)Format, <span class="string">&quot;flag is you input&quot;</span>);</span><br><span class="line">      *(_QWORD *)(a2 + <span class="number">56</span>) = <span class="number">18</span>i64;</span><br><span class="line">      <span class="built_in">DbgPrint</span>(&amp;byte_140001FC0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>((<span class="type">char</span> *)Format, <span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">      *(_QWORD *)(a2 + <span class="number">56</span>) = <span class="number">6</span>i64;</span><br><span class="line">      <span class="built_in">DbgPrint</span>(&amp;byte_140001FE0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v10 != <span class="number">2237440</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DbgPrint</span>(aIrpdevicecontr, v11);</span><br><span class="line">  <span class="built_in">DbgPrint</span>(<span class="string">&quot;CODE_WRITE %X\n&quot;</span>, <span class="number">2237440</span>i64);</span><br><span class="line">  <span class="built_in">DbgPrint</span>(Format);</span><br><span class="line">  *(_QWORD *)(a2 + <span class="number">56</span>) = <span class="number">0</span>i64;</span><br><span class="line">LABEL_21:</span><br><span class="line">  *(_QWORD *)(a2 + <span class="number">56</span>) = <span class="number">65</span>i64;</span><br><span class="line">  <span class="built_in">IofCompleteRequest</span>((PIRP)a2, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sub_140001A70</strong>函数如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">sub_140001A70</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+4h] [rbp-44h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-40h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> *v5; <span class="comment">// [rsp+10h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+18h] [rbp-30h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">16</span>]; <span class="comment">// [rsp+20h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  v7[<span class="number">1</span>] = a2 ^ <span class="number">0x25</span>;</span><br><span class="line">  v7[<span class="number">0</span>] = a2 ^ <span class="number">0x7A</span>;</span><br><span class="line">  v7[<span class="number">8</span>] = a2 ^ <span class="number">0x1A</span>;</span><br><span class="line">  v7[<span class="number">2</span>] = a2 ^ <span class="number">0x35</span>;</span><br><span class="line">  v7[<span class="number">9</span>] = a2 ^ <span class="number">0x6D</span>;</span><br><span class="line">  v7[<span class="number">3</span>] = a2 ^ <span class="number">0x23</span>;</span><br><span class="line">  v7[<span class="number">11</span>] = a2 ^ <span class="number">0x94</span>;</span><br><span class="line">  v7[<span class="number">4</span>] = a2 ^ <span class="number">0xC5</span>;</span><br><span class="line">  v7[<span class="number">5</span>] = a2 ^ <span class="number">0x4B</span>;</span><br><span class="line">  v7[<span class="number">6</span>] = a2 ^ <span class="number">0x21</span>;</span><br><span class="line">  v7[<span class="number">7</span>] = a2 ^ <span class="number">0x35</span>;</span><br><span class="line">  v7[<span class="number">10</span>] = a2 ^ <span class="number">0x91</span>;</span><br><span class="line">  v7[<span class="number">12</span>] = a2 ^ <span class="number">0x2C</span>;</span><br><span class="line">  v7[<span class="number">13</span>] = a2 ^ <span class="number">0xC1</span>;</span><br><span class="line">  v7[<span class="number">14</span>] = a2 ^ <span class="number">0x92</span>;</span><br><span class="line">  v7[<span class="number">15</span>] = a2 ^ <span class="number">0x51</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = &amp;v4;</span><br><span class="line">    v4 = *a1 ^ a2;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = (<span class="type">int</span> *)((<span class="type">char</span> *)v5 + <span class="number">1</span>);</span><br><span class="line">      *((_BYTE *)v5 - <span class="number">1</span>) ^= v7[<span class="number">15</span> - (((<span class="type">unsigned</span> __int8)i + (<span class="type">unsigned</span> __int8)j) &amp; <span class="number">0xF</span>)] | ((<span class="type">unsigned</span> __int8)j &lt;&lt; j) | j | <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v6 = ~a2 ^ v4;</span><br><span class="line">    *a1++ = v6;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实自己主要是栽倒到了类型转换，还有指针运用的问题</p><p>根据以上加密程序写出解密exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">uint32_t</span>* p, <span class="type">char</span>* res, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">res[k + j + <span class="number">4</span> * i] = (p[i] &gt;&gt; (<span class="number">8</span> * j)) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">char_to_uint</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p,<span class="type">int</span> k,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> res = p[k + <span class="number">4</span> * i] | p[k + <span class="number">1</span> + <span class="number">4</span> * i] &lt;&lt; <span class="number">8</span> | p[k + <span class="number">2</span> + <span class="number">4</span> * i] &lt;&lt; <span class="number">16</span> | p[k + <span class="number">3</span> + <span class="number">4</span> * i] &lt;&lt; <span class="number">24</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">swap</span><span class="params">(<span class="type">uint32_t</span> num)</span> &#123;</span><br><span class="line">num = (num &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span> | ((num &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span> | ((num &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span> | ((num &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">char_to_uint32</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* p, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> result = p[k]|p[k+<span class="number">1</span>]&lt;&lt;<span class="number">8</span> | p[k + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>| p[k + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> rounds, <span class="type">uint32_t</span> * a2, <span class="type">uint32_t</span>* a3)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sum, v0, v1, i;</span><br><span class="line"></span><br><span class="line">v0 = a2[<span class="number">0</span>];</span><br><span class="line">v1 = a2[<span class="number">1</span>];</span><br><span class="line">sum = <span class="number">1697034457</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rounds; ++i) &#123;</span><br><span class="line">v1 -= (a3[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>] + sum) ^ (v0 + ((v0 &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * v0)));</span><br><span class="line">sum += <span class="number">1640531527</span>;</span><br><span class="line">v0 -= (a3[sum &amp; <span class="number">3</span>] + sum) ^ (v1 + ((v1 &gt;&gt; <span class="number">6</span>) ^ (<span class="number">16</span> * v1)));</span><br><span class="line">&#125;</span><br><span class="line">a2[<span class="number">0</span>] = v0;</span><br><span class="line">a2[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *flag, <span class="type">int</span> k, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> v7[<span class="number">16</span>];</span><br><span class="line">v7[<span class="number">1</span>] = i ^ <span class="number">0x25</span>;</span><br><span class="line">v7[<span class="number">0</span>] = i ^ <span class="number">0x7a</span>;</span><br><span class="line">v7[<span class="number">8</span>] = i ^ <span class="number">0x1a</span>;</span><br><span class="line">v7[<span class="number">2</span>] = i ^ <span class="number">0x35</span>;</span><br><span class="line">v7[<span class="number">9</span>] = i ^ <span class="number">0x6d</span>;</span><br><span class="line">v7[<span class="number">3</span>] = i ^ <span class="number">0x23</span>;</span><br><span class="line">v7[<span class="number">11</span>] = i ^ <span class="number">0x94</span>;</span><br><span class="line">v7[<span class="number">4</span>] = i ^ <span class="number">0xc5</span>;</span><br><span class="line">v7[<span class="number">5</span>] = i ^ <span class="number">0x4b</span>;</span><br><span class="line">v7[<span class="number">6</span>] = i ^ <span class="number">0x21</span>;</span><br><span class="line">v7[<span class="number">7</span>] = i ^ <span class="number">0x35</span>;</span><br><span class="line">v7[<span class="number">10</span>] = i ^ <span class="number">0x91</span>;</span><br><span class="line">v7[<span class="number">12</span>] = i ^ <span class="number">0x2c</span>;</span><br><span class="line">v7[<span class="number">13</span>] = i ^ <span class="number">0xc1</span>;</span><br><span class="line">v7[<span class="number">14</span>] = i ^ <span class="number">0x92</span>;</span><br><span class="line">v7[<span class="number">15</span>] = i ^ <span class="number">0x51</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> z= <span class="number">0</span>; z &lt; <span class="number">4</span>; z++) </span><br><span class="line">&#123;</span><br><span class="line">flag[k + <span class="number">4</span> * z] ^= i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sum = v7[<span class="number">15</span> - ((z + j) &amp; <span class="number">0xf</span>)] |(j &lt;&lt; j) | j | <span class="number">4</span>;</span><br><span class="line">flag[k + <span class="number">4</span> * z + j] ^= sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v6 = char_to_uint32(flag, k + <span class="number">4</span> * z);</span><br><span class="line">v6 ^= (~i) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> e = <span class="number">0</span>; e &lt; <span class="number">4</span>; e++)</span><br><span class="line">&#123;</span><br><span class="line">flag[k + <span class="number">4</span> * z + e] = (v6 &gt;&gt; (<span class="number">8</span> * e)) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> flag[<span class="number">32</span>] = &#123; <span class="number">0x72</span>, <span class="number">0x62</span>, <span class="number">0xae</span>, <span class="number">0x34</span>, <span class="number">0x52</span>, <span class="number">0x9a</span>, <span class="number">0x06</span>, <span class="number">0xaf</span>, <span class="number">0x72</span>, <span class="number">0xfb</span>, <span class="number">0x40</span>, <span class="number">0xc0</span>, <span class="number">0x10</span>, <span class="number">0x35</span>, <span class="number">0xbd</span>, <span class="number">0xd4</span>, <span class="number">0x22</span>, <span class="number">0xa5</span>, <span class="number">0x93</span>, <span class="number">0x07</span>, <span class="number">0xb4</span>, <span class="number">0xfb</span>, <span class="number">0xb5</span>, <span class="number">0xca</span>, <span class="number">0xe8</span>, <span class="number">0x01</span>, <span class="number">0xf5</span>, <span class="number">0xae</span>, <span class="number">0xed</span>, <span class="number">0x7b</span>, <span class="number">0xb8</span>, <span class="number">0x6a</span> &#125;;<span class="type">uint32_t</span> k[<span class="number">4</span>] = &#123; <span class="number">0x1a2b</span>, <span class="number">0x3a4d</span>, <span class="number">0x5e6f</span>, <span class="number">0xaa33</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">func(flag, i * <span class="number">16</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line"><span class="type">uint32_t</span> p[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">p[<span class="number">0</span>] = char_to_uint(flag, i, <span class="number">0</span>);</span><br><span class="line">p[<span class="number">1</span>] = char_to_uint(flag, i, <span class="number">1</span>);</span><br><span class="line">p[<span class="number">0</span>] = swap(p[<span class="number">0</span>]);</span><br><span class="line">p[<span class="number">1</span>] = swap(p[<span class="number">1</span>]);</span><br><span class="line">decrypt(<span class="number">33</span>, p, k);</span><br><span class="line">p[<span class="number">0</span>] = swap(p[<span class="number">0</span>]);</span><br><span class="line">p[<span class="number">1</span>] = swap(p[<span class="number">1</span>]);</span><br><span class="line">func1(p, flag, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, flag[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下自己的问题吧，对于类型转换和指针掌握的不是那么熟</p><p>这几天一直在弄动调的问题，没有静下心来静态分析，接下来就是动态调试这个驱动</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当时这道题在比赛的时候，因为自己对c语言的学艺不精，没有解出来&lt;br&gt;这是道驱动逆向题，但是最简单的方法用不到动调&lt;/p&gt;
&lt;p&gt;以下是主要加密程序&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    <category term="驱动逆向" scheme="https://5m10v3.github.io/categories/%E9%A9%B1%E5%8A%A8%E9%80%86%E5%90%91/"/>
    
    
    <category term="ctf学习" scheme="https://5m10v3.github.io/tags/ctf%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>日记(20)</title>
    <link href="https://5m10v3.github.io/2024/04/08/%E6%97%A5%E8%AE%B0(20)/"/>
    <id>https://5m10v3.github.io/2024/04/08/%E6%97%A5%E8%AE%B0(20)/</id>
    <published>2024-04-07T16:00:00.000Z</published>
    <updated>2024-04-08T14:24:05.727Z</updated>
    
    <content type="html"><![CDATA[<p>有一段时间没有更新日记了，日记这个好习惯还是要继续坚持的<br>近期遇到的麻烦<br>如何动调sys（长城杯-ez_driver）这道题<br>总结一下里面需要用到的知识吧</p><ul><li>IRP请求</li><li>内核通信</li></ul><p>还是要学习一下关于内核的一些知识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">近期的任务</span><br><span class="line">1.windows内核驱动学习</span><br><span class="line">2.继续学习ollvm混淆</span><br><span class="line">3.研究upx源码</span><br><span class="line">4.穿插着练题</span><br><span class="line">2-4条都是穿插来</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有一段时间没有更新日记了，日记这个好习惯还是要继续坚持的&lt;br&gt;近期遇到的麻烦&lt;br&gt;如何动调sys（长城杯-ez_driver）这道题&lt;br&gt;总结一下里面需要用到的知识吧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IRP请求&lt;/li&gt;
&lt;li&gt;内核通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还是要</summary>
      
    
    
    
    <category term="日记" scheme="https://5m10v3.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="学习" scheme="https://5m10v3.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
